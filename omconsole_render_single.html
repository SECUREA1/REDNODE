<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="color-scheme" content="dark" />
  <title>OMConsole — Multi-Modal Control Dashboard</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop stop-color='%230b2a66'/%3E%3Cstop offset='1' stop-color='%23d4af37'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='64' height='64' rx='14' fill='url(%23g)'/%3E%3Cpath d='M18 34c6-12 22-12 28 0' fill='none' stroke='%23fff' stroke-width='4' stroke-linecap='round'/%3E%3Ccircle cx='32' cy='32' r='4' fill='%23fff'/%3E%3C/svg%3E" />

  <!-- MediaPipe (CDN) -->
  <script defer src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>

  <style>
    :root{
      --bg0:#071428;
      --bg1:#0a1e3a;
      --panel: rgba(13, 31, 60, .62);
      --panel2: rgba(9, 20, 40, .58);
      --stroke: rgba(212,175,55,.18);
      --stroke2: rgba(140,180,255,.16);
      --text:#eaf2ff;
      --muted:#9bb0d1;
      --blue:#0b2a66;
      --blue2:#12408c;
      --gold:#d4af37;
      --gold2:#f2d57a;
      --danger:#ff4d4d;
      --ok:#32d583;
      --shadow: 0 30px 90px rgba(0,0,0,.45);
      --shadow2: 0 16px 45px rgba(0,0,0,.35);
      --glass: blur(14px) saturate(130%);
      --radius-xl: 26px;
      --radius-lg: 18px;
      --radius-md: 14px;
      --radius-sm: 12px;
      --pad: 18px;
      --pad2: 14px;
      --pad3: 10px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      --ease: cubic-bezier(.22,.61,.36,1);
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: var(--sans);
      color: var(--text);
      background:
        radial-gradient(1200px 800px at 18% 10%, rgba(18,64,140,.30), transparent 60%),
        radial-gradient(900px 600px at 80% 18%, rgba(212,175,55,.20), transparent 55%),
        radial-gradient(1100px 700px at 60% 90%, rgba(18,64,140,.20), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      overflow:hidden;
      user-select:none;
    }

    .app{
      height:100%;
      display:grid;
      grid-template-columns: 340px 1fr;
      grid-template-rows: 84px 1fr;
      grid-template-areas:
        "sidebar topbar"
        "sidebar main";
      gap: 14px;
      padding: 16px;
    }

    /* Topbar */
    .topbar{
      grid-area: topbar;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 14px 18px;
      border-radius: var(--radius-xl);
      background: linear-gradient(180deg, rgba(13, 31, 60, .65), rgba(9, 20, 40, .55));
      backdrop-filter: var(--glass);
      box-shadow: var(--shadow2);
      border: 1px solid var(--stroke2);
      position:relative;
      overflow:hidden;
    }
    .topbar:before{
      content:"";
      position:absolute; inset:-1px;
      background:
        radial-gradient(800px 200px at 20% 0%, rgba(212,175,55,.13), transparent 60%),
        radial-gradient(900px 260px at 70% 0%, rgba(140,180,255,.12), transparent 55%);
      pointer-events:none;
    }
    .brand{
      display:flex; align-items:center; gap:12px; position:relative;
    }
    .logo{
      width:42px;height:42px;border-radius:14px;
      background: linear-gradient(135deg, rgba(11,42,102,.95), rgba(212,175,55,.9));
      box-shadow: 0 12px 30px rgba(0,0,0,.4);
      border:1px solid rgba(255,255,255,.08);
      display:grid; place-items:center;
    }
    .logo svg{width:26px;height:26px;opacity:.96}
    .brand h1{
      margin:0;
      font-size: 16.5px;
      letter-spacing:.35px;
      font-weight:700;
    }
    .brand .sub{
      font-size: 12px;
      color: var(--muted);
      margin-top:3px;
    }
    .top-actions{display:flex; align-items:center; gap:10px; position:relative;}
    .pill{
      display:flex; align-items:center; gap:10px;
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(7, 20, 40, .55);
      border: 1px solid rgba(212,175,55,.18);
      box-shadow: 0 16px 35px rgba(0,0,0,.25) inset;
    }
    .pill b{font-size:12px; letter-spacing:.3px}
    .dot{
      width:10px;height:10px;border-radius:999px;
      background: rgba(255,255,255,.2);
      box-shadow: 0 0 0 3px rgba(255,255,255,.06);
    }
    .dot.ok{background: var(--ok); box-shadow: 0 0 0 3px rgba(50,213,131,.16), 0 0 18px rgba(50,213,131,.35)}
    .dot.bad{background: var(--danger); box-shadow: 0 0 0 3px rgba(255,77,77,.16), 0 0 18px rgba(255,77,77,.35)}

    .btn{
      appearance:none; border:none;
      background: linear-gradient(180deg, rgba(18,64,140,.9), rgba(10,30,58,.9));
      color: var(--text);
      border: 1px solid rgba(212,175,55,.22);
      border-radius: 14px;
      padding: 10px 12px;
      font-weight: 700;
      letter-spacing: .2px;
      cursor:pointer;
      transition: transform .15s var(--ease), filter .15s var(--ease), box-shadow .15s var(--ease);
      box-shadow: 0 14px 30px rgba(0,0,0,.35);
    }
    .btn:hover{transform: translateY(-1px); filter: brightness(1.06)}
    .btn:active{transform: translateY(0px) scale(.99)}
    .btn.gold{
      background: linear-gradient(180deg, rgba(212,175,55,.96), rgba(165,129,25,.92));
      color: #0a1330;
      border-color: rgba(255,255,255,.12);
      box-shadow: 0 14px 30px rgba(212,175,55,.20);
    }
    .btn.ghost{
      background: rgba(7, 20, 40, .45);
      border-color: rgba(140,180,255,.18);
    }

    /* Sidebar */
    .sidebar{
      grid-area: sidebar;
      border-radius: var(--radius-xl);
      background: linear-gradient(180deg, rgba(13, 31, 60, .62), rgba(9, 20, 40, .52));
      border: 1px solid var(--stroke2);
      backdrop-filter: var(--glass);
      box-shadow: var(--shadow2);
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }
    .side-head{
      padding: 18px;
      border-bottom: 1px solid rgba(140,180,255,.12);
      position:relative;
    }
    .side-head:after{
      content:"";
      position:absolute; inset:auto 0 -1px 0; height:1px;
      background: linear-gradient(90deg, transparent, rgba(212,175,55,.30), transparent);
      opacity:.9;
    }
    .side-head .title{
      font-weight:800;
      letter-spacing:.28px;
      font-size: 13.5px;
      color: rgba(234,242,255,.92);
    }
    .side-head .desc{
      font-size: 12px;
      color: var(--muted);
      margin-top:6px;
      line-height: 1.35;
    }
    .nav{
      padding: 14px;
      display:flex;
      flex-direction:column;
      gap:10px;
      overflow:auto;
    }
    .group{
      border: 1px solid rgba(212,175,55,.14);
      border-radius: var(--radius-lg);
      background: rgba(7, 20, 40, .35);
      padding: 12px;
      box-shadow: 0 18px 40px rgba(0,0,0,.22) inset;
    }
    .group .gtitle{
      font-size:12px;
      color: rgba(242,213,122,.88);
      letter-spacing:.3px;
      font-weight:800;
      margin-bottom:10px;
      display:flex; align-items:center; justify-content:space-between;
    }
    .badge{
      font-family: var(--mono);
      font-size: 11px;
      color: rgba(234,242,255,.85);
      padding: 4px 8px;
      border-radius: 999px;
      border:1px solid rgba(140,180,255,.18);
      background: rgba(9, 20, 40, .4);
    }
    .navbtn{
      width:100%;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 10px 10px;
      border-radius: 14px;
      border:1px solid rgba(140,180,255,.14);
      background: linear-gradient(180deg, rgba(10,30,58,.70), rgba(7,20,40,.55));
      color: var(--text);
      cursor:pointer;
      transition: transform .14s var(--ease), filter .14s var(--ease), border-color .14s var(--ease);
    }
    .navbtn:hover{transform: translateY(-1px); filter: brightness(1.06); border-color: rgba(212,175,55,.28)}
    .navbtn:active{transform: translateY(0px) scale(.995)}
    .navbtn .left{
      display:flex; align-items:center; gap:10px;
    }
    .icon{
      width:30px;height:30px;border-radius:12px;
      background: rgba(18,64,140,.30);
      border:1px solid rgba(212,175,55,.18);
      display:grid; place-items:center;
      box-shadow: 0 12px 26px rgba(0,0,0,.28);
      flex:none;
    }
    .icon svg{width:18px;height:18px;opacity:.95}
    .navbtn .label{
      font-weight:800;
      letter-spacing:.18px;
      font-size: 13px;
      text-align:left;
    }
    .navbtn .sublabel{
      font-size: 11.5px;
      color: var(--muted);
      margin-top:2px;
    }
    .navbtn .right{
      display:flex; flex-direction:column; align-items:flex-end; gap:4px;
      font-family: var(--mono);
      font-size: 11px;
      color: rgba(234,242,255,.78);
    }
    .navbtn.active{
      border-color: rgba(212,175,55,.45);
      background: linear-gradient(180deg, rgba(18,64,140,.78), rgba(7,20,40,.55));
      box-shadow: 0 0 0 1px rgba(212,175,55,.12), 0 24px 45px rgba(0,0,0,.36);
    }

    .side-foot{
      margin-top:auto;
      padding: 14px 18px;
      border-top: 1px solid rgba(140,180,255,.12);
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .kv{
      display:flex; align-items:center; justify-content:space-between;
      font-size: 12px;
      color: var(--muted);
      padding: 8px 10px;
      border-radius: 14px;
      border:1px solid rgba(140,180,255,.12);
      background: rgba(7, 20, 40, .32);
    }
    .kv b{color: rgba(234,242,255,.92); font-family:var(--mono); font-size: 11.5px}

    /* Main */
    .main{
      grid-area: main;
      border-radius: var(--radius-xl);
      background: linear-gradient(180deg, rgba(13, 31, 60, .55), rgba(9, 20, 40, .40));
      border: 1px solid rgba(140,180,255,.16);
      backdrop-filter: var(--glass);
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }

    .stage{
      position:absolute; inset: 0;
      display:grid;
      grid-template-columns: 1fr 380px;
      gap: 12px;
      padding: 16px;
    }
    .viewport{
      border-radius: var(--radius-xl);
      border: 1px solid rgba(212,175,55,.18);
      background:
        radial-gradient(900px 600px at 20% 20%, rgba(18,64,140,.26), transparent 60%),
        radial-gradient(700px 500px at 80% 10%, rgba(212,175,55,.18), transparent 55%),
        linear-gradient(180deg, rgba(7,20,40,.92), rgba(6,16,30,.92));
      box-shadow: 0 30px 80px rgba(0,0,0,.35);
      overflow:hidden;
      position:relative;
    }
    canvas#viz{
      width:100%;
      height:100%;
      display:block;
    }
    .panel{
      border-radius: var(--radius-xl);
      border: 1px solid rgba(140,180,255,.16);
      background: rgba(7, 20, 40, .40);
      box-shadow: 0 26px 70px rgba(0,0,0,.30);
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }
    .panel .ph{
      padding: 14px 14px 12px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      border-bottom:1px solid rgba(140,180,255,.12);
      background: linear-gradient(180deg, rgba(9, 20, 40, .55), rgba(7, 20, 40, .25));
    }
    .panel .ph .pt{
      font-size: 12.5px;
      letter-spacing:.28px;
      font-weight:900;
      color: rgba(242,213,122,.92);
    }
    .panel .ph .ps{
      font-family: var(--mono);
      font-size: 11.5px;
      color: rgba(234,242,255,.75);
    }
    .panel .pc{
      padding: 14px;
      overflow:auto;
      display:flex;
      flex-direction:column;
      gap: 14px;
    }

    /* Cards / form */
    .card{
      border-radius: 18px;
      border: 1px solid rgba(212,175,55,.14);
      background: rgba(7, 20, 40, .34);
      box-shadow: 0 20px 55px rgba(0,0,0,.22) inset;
      padding: 12px;
    }
    .card .ct{
      font-weight:900;
      letter-spacing:.22px;
      font-size: 12px;
      color: rgba(234,242,255,.92);
      display:flex; align-items:center; justify-content:space-between;
      margin-bottom:10px;
    }
    .hint{
      color: var(--muted);
      font-size: 12px;
      line-height: 1.4;
    }
    .row{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    }
    .row > * {flex: 1 1 auto}
    label{
      font-size: 11.5px;
      color: rgba(234,242,255,.84);
      font-weight:800;
      letter-spacing:.18px;
    }
    input[type="range"]{width:100%}
    .kv2{
      display:flex; align-items:center; justify-content:space-between;
      font-family: var(--mono);
      font-size: 11.5px;
      color: rgba(234,242,255,.82);
      padding-top: 6px;
    }
    .smallbtn{
      padding: 8px 10px;
      border-radius: 14px;
      border:1px solid rgba(212,175,55,.18);
      background: rgba(18,64,140,.30);
      color: var(--text);
      font-weight:900;
      cursor:pointer;
      transition: transform .14s var(--ease), filter .14s var(--ease);
    }
    .smallbtn:hover{transform: translateY(-1px); filter: brightness(1.06)}
    .smallbtn:active{transform: translateY(0px) scale(.99)}
    .smallbtn.gold{
      background: linear-gradient(180deg, rgba(212,175,55,.90), rgba(165,129,25,.88));
      color: #061022;
      border-color: rgba(255,255,255,.10);
    }
    .smallbtn.danger{
      background: rgba(255,77,77,.18);
      border-color: rgba(255,77,77,.25);
    }
    .smallbtn.ghost{
      background: rgba(7, 20, 40, .35);
      border-color: rgba(140,180,255,.16);
    }

    /* Cursor overlay */
    #cursor{
      position:fixed;
      left:0;top:0;
      width:24px;height:24px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.95), rgba(212,175,55,.92) 35%, rgba(11,42,102,.92) 70%);
      box-shadow:
        0 0 0 4px rgba(212,175,55,.12),
        0 0 30px rgba(212,175,55,.22),
        0 0 48px rgba(140,180,255,.18);
      transform: translate(-100px, -100px);
      pointer-events:none;
      z-index: 9999;
      mix-blend-mode: screen;
    }
    #cursor.click{
      box-shadow:
        0 0 0 6px rgba(50,213,131,.18),
        0 0 38px rgba(50,213,131,.35),
        0 0 60px rgba(212,175,55,.18);
    }

    /* Modals */
    .modal{
      position:absolute; inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,.46);
      backdrop-filter: blur(8px);
      z-index: 50;
    }
    .modal.show{display:flex}
    .sheet{
      width: min(980px, 92vw);
      max-height: min(86vh, 820px);
      border-radius: 26px;
      border: 1px solid rgba(212,175,55,.22);
      background: linear-gradient(180deg, rgba(13,31,60,.86), rgba(7,20,40,.80));
      box-shadow: var(--shadow);
      overflow:hidden;
      display:flex; flex-direction:column;
    }
    .sheet .sh{
      padding: 14px 16px;
      display:flex; align-items:center; justify-content:space-between;
      border-bottom: 1px solid rgba(140,180,255,.14);
      background:
        radial-gradient(700px 200px at 20% 0%, rgba(212,175,55,.12), transparent 60%),
        linear-gradient(180deg, rgba(9,20,40,.70), rgba(7,20,40,.36));
    }
    .sheet .sh .ttl{
      font-weight: 950;
      letter-spacing: .25px;
      font-size: 13px;
      color: rgba(242,213,122,.92);
    }
    .sheet .sb{
      padding: 16px;
      overflow:auto;
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap: 14px;
    }
    .sheet .left{
      display:flex;
      flex-direction:column;
      gap: 12px;
    }
    .sheet .right{
      display:flex;
      flex-direction:column;
      gap: 12px;
    }

    .grid2{display:grid; grid-template-columns: 1fr 1fr; gap: 10px;}
    .grid3{display:grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px;}

    .kbd{
      display:grid;
      grid-template-columns: repeat(10, 1fr);
      gap: 8px;
    }
    .key{
      padding: 10px 0;
      border-radius: 14px;
      border:1px solid rgba(140,180,255,.14);
      background: rgba(18,64,140,.25);
      font-weight: 900;
      cursor:pointer;
      text-align:center;
      transition: transform .14s var(--ease), filter .14s var(--ease), border-color .14s var(--ease);
    }
    .key:hover{transform: translateY(-1px); filter: brightness(1.06); border-color: rgba(212,175,55,.28)}
    .key.wide{grid-column: span 3}
    .key.wider{grid-column: span 5}
    .key.danger{background: rgba(255,77,77,.18); border-color: rgba(255,77,77,.22)}
    .key.gold{background: linear-gradient(180deg, rgba(212,175,55,.90), rgba(165,129,25,.88)); color:#061022; border-color: rgba(255,255,255,.12)}
    .hidden{display:none !important}

    /* Responsive */
    @media (max-width: 1200px){
      .app{grid-template-columns: 320px 1fr;}
      .stage{grid-template-columns: 1fr; grid-template-rows: 1fr 360px;}
      .panel{height: 360px}
    }
    @media (max-width: 900px){
      body{overflow:auto}
      .app{grid-template-columns: 1fr; grid-template-rows: auto auto 1fr; grid-template-areas: "topbar" "sidebar" "main";}
      .sidebar{max-height: 520px}
    }
  </style>
</head>
<body>
<div class="app">
  <aside class="sidebar">
    <div class="side-head">
      <div class="title">SYSTEM MODULES</div>
      <div class="desc">
        Blue/Gold console optimized for high-DPI. Use a control system, then tune &amp; <b>Save</b> to activate.
        <br/><span style="color:rgba(242,213,122,.92); font-weight:900">Note:</span> Browsers cannot take over your OS mouse for security. This console provides an <b>in-app cursor</b> and click automation across the UI.
      </div>
    </div>
    <div class="nav">
      <div class="group">
        <div class="gtitle">
          Apps <span class="badge" id="badgeMode">DASHBOARD</span>
        </div>
        <button class="navbtn" data-open="internet" id="btnInternet">
          <div class="left">
            <div class="icon">
              <svg viewBox="0 0 24 24" fill="none"><path d="M12 21a9 9 0 1 0 0-18 9 9 0 0 0 0 18Z" stroke="white" opacity=".9" stroke-width="1.7"/><path d="M3 12h18" stroke="white" opacity=".8" stroke-width="1.7"/><path d="M12 3c2.6 2.5 4.2 5.6 4.2 9s-1.6 6.5-4.2 9c-2.6-2.5-4.2-5.6-4.2-9S9.4 5.5 12 3Z" stroke="white" opacity=".8" stroke-width="1.7"/></svg>
            </div>
            <div>
              <div class="label">Internet</div>
              <div class="sublabel">Open web in new tab</div>
            </div>
          </div>
          <div class="right"><span>⌘</span><span>ALT+I</span></div>
        </button>

        <button class="navbtn" data-open="games" id="btnGames">
          <div class="left">
            <div class="icon">
              <svg viewBox="0 0 24 24" fill="none"><path d="M7 9h10a4 4 0 0 1 4 4v2.5A3.5 3.5 0 0 1 17.5 19h-1l-1.7-1.7a4 4 0 0 0-5.6 0L7.5 19h-1A3.5 3.5 0 0 1 3 15.5V13a4 4 0 0 1 4-4Z" stroke="white" opacity=".9" stroke-width="1.7"/><path d="M8 13h3M9.5 11.5v3" stroke="white" opacity=".9" stroke-width="1.7" stroke-linecap="round"/><path d="M16 12.7h.01M18 14.3h.01" stroke="white" opacity=".9" stroke-width="2.4" stroke-linecap="round"/></svg>
            </div>
            <div>
              <div class="label">Games</div>
              <div class="sublabel">Built-in simulation</div>
            </div>
          </div>
          <div class="right"><span>⌘</span><span>ALT+G</span></div>
        </button>

        <button class="navbtn" data-open="notepad" id="btnNotepad">
          <div class="left">
            <div class="icon">
              <svg viewBox="0 0 24 24" fill="none"><path d="M7 3h10a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2Z" stroke="white" opacity=".9" stroke-width="1.7"/><path d="M8 8h8M8 12h8M8 16h5" stroke="white" opacity=".85" stroke-width="1.7" stroke-linecap="round"/></svg>
            </div>
            <div>
              <div class="label">Notepad</div>
              <div class="sublabel">On-screen keyboard</div>
            </div>
          </div>
          <div class="right"><span>⌘</span><span>ALT+N</span></div>
        </button>

        <button class="navbtn" data-open="audio" id="btnAudio">
          <div class="left">
            <div class="icon">
              <svg viewBox="0 0 24 24" fill="none"><path d="M12 15a3 3 0 0 0 3-3V7a3 3 0 0 0-6 0v5a3 3 0 0 0 3 3Z" stroke="white" opacity=".9" stroke-width="1.7"/><path d="M19 11v1a7 7 0 0 1-14 0v-1" stroke="white" opacity=".85" stroke-width="1.7" stroke-linecap="round"/><path d="M12 19v2" stroke="white" opacity=".85" stroke-width="1.7" stroke-linecap="round"/></svg>
            </div>
            <div>
              <div class="label">Audio</div>
              <div class="sublabel">Record / playback</div>
            </div>
          </div>
          <div class="right"><span>⌘</span><span>ALT+A</span></div>
        </button>

        <button class="navbtn" data-open="video" id="btnVideo">
          <div class="left">
            <div class="icon">
              <svg viewBox="0 0 24 24" fill="none"><path d="M4 7a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V7Z" stroke="white" opacity=".9" stroke-width="1.7"/><path d="M17 10l4-2v8l-4-2" stroke="white" opacity=".85" stroke-width="1.7" stroke-linejoin="round"/></svg>
            </div>
            <div>
              <div class="label">Video</div>
              <div class="sublabel">Capture / playback</div>
            </div>
          </div>
          <div class="right"><span>⌘</span><span>ALT+V</span></div>
        </button>

        <button class="navbtn" data-open="calendar" id="btnCalendar">
          <div class="left">
            <div class="icon">
              <svg viewBox="0 0 24 24" fill="none"><path d="M7 3v3M17 3v3" stroke="white" opacity=".9" stroke-width="1.7" stroke-linecap="round"/><path d="M4 7h16" stroke="white" opacity=".85" stroke-width="1.7"/><path d="M6 5h12a2 2 0 0 1 2 2v13a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2Z" stroke="white" opacity=".9" stroke-width="1.7"/></svg>
            </div>
            <div>
              <div class="label">Calendar</div>
              <div class="sublabel">Bookings + time slots</div>
            </div>
          </div>
          <div class="right"><span>⌘</span><span>ALT+C</span></div>
        </button>
      </div>

      <div class="group">
        <div class="gtitle">
          Controls <span class="badge" id="badgeControl">GESTURE</span>
        </div>
        <button class="navbtn" data-open="controlSelector" id="btnControlSelector">
          <div class="left">
            <div class="icon">
              <svg viewBox="0 0 24 24" fill="none"><path d="M4 12h6M14 12h6" stroke="white" opacity=".88" stroke-width="1.7" stroke-linecap="round"/><path d="M10 8l-2 8" stroke="white" opacity=".88" stroke-width="1.7" stroke-linecap="round"/><path d="M16 16l2-8" stroke="white" opacity=".88" stroke-width="1.7" stroke-linecap="round"/></svg>
            </div>
            <div>
              <div class="label">Control Selector</div>
              <div class="sublabel">Assign controllers to tasks</div>
            </div>
          </div>
          <div class="right"><span>⌘</span><span>ALT+S</span></div>
        </button>

        <div class="grid2">
          
          <button class="navbtn" data-open="gestureTuner" id="btnGestureTuner">
            <div class="left">
              <div class="icon">
                <svg viewBox="0 0 24 24" fill="none">
                  <path d="M8 12V6.8a1.8 1.8 0 1 1 3.6 0V12" stroke="white" opacity=".9" stroke-width="1.7" stroke-linecap="round"/>
                  <path d="M11.6 12V5.6a1.8 1.8 0 1 1 3.6 0V12" stroke="white" opacity=".9" stroke-width="1.7" stroke-linecap="round"/>
                  <path d="M15.2 12V7.4a1.8 1.8 0 1 1 3.6 0V13c0 4-2.6 7-6.6 7H11c-4 0-7-2.8-7-6.8V11a1.8 1.8 0 1 1 3.6 0v1" stroke="white" opacity=".85" stroke-width="1.7" stroke-linecap="round"/>
                </svg>
              </div>
              <div>
                <div class="label">Gesture</div>
                <div class="sublabel">Hands + Pinch</div>
              </div>
            </div>
            <div class="right"><span>TUNE</span><span>ALT+H</span></div>
          </button>

<button class="navbtn" data-open="retinaTuner" id="btnRetinaTuner">
            <div class="left">
              <div class="icon">
                <svg viewBox="0 0 24 24" fill="none"><path d="M2 12s4-7 10-7 10 7 10 7-4 7-10 7S2 12 2 12Z" stroke="white" opacity=".9" stroke-width="1.7"/><path d="M12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z" stroke="white" opacity=".85" stroke-width="1.7"/></svg>
              </div>
              <div>
                <div class="label">Retina</div>
                <div class="sublabel">FaceMesh + Iris</div>
              </div>
            </div>
            <div class="right"><span>TUNE</span><span>ALT+R</span></div>
          </button>

          <button class="navbtn" data-open="emgTuner" id="btnEmgTuner">
            <div class="left">
              <div class="icon">
                <svg viewBox="0 0 24 24" fill="none"><path d="M6 7h12M6 12h12M6 17h12" stroke="white" opacity=".9" stroke-width="1.7" stroke-linecap="round"/><path d="M4 6v12" stroke="white" opacity=".75" stroke-width="1.7"/></svg>
              </div>
              <div>
                <div class="label">EMG</div>
                <div class="sublabel">SIM / WebSerial</div>
              </div>
            </div>
            <div class="right"><span>TUNE</span><span>ALT+E</span></div>
          </button>

          <button class="navbtn" data-open="eegTuner" id="btnEegTuner">
            <div class="left">
              <div class="icon">
                <svg viewBox="0 0 24 24" fill="none"><path d="M7 7c1-2 3-3 5-3s4 1 5 3" stroke="white" opacity=".9" stroke-width="1.7" stroke-linecap="round"/><path d="M5 11c0-2 1-4 2-5" stroke="white" opacity=".85" stroke-width="1.7" stroke-linecap="round"/><path d="M19 11c0-2-1-4-2-5" stroke="white" opacity=".85" stroke-width="1.7" stroke-linecap="round"/><path d="M8 20c-2-2-3-4-3-7 0-2 1-4 2-6" stroke="white" opacity=".65" stroke-width="1.7" stroke-linecap="round"/><path d="M16 20c2-2 3-4 3-7 0-2-1-4-2-6" stroke="white" opacity=".65" stroke-width="1.7" stroke-linecap="round"/></svg>
              </div>
              <div>
                <div class="label">EEG</div>
                <div class="sublabel">SIM / WebSerial</div>
              </div>
            </div>
            <div class="right"><span>TUNE</span><span>ALT+Q</span></div>
          </button>

          <button class="navbtn" data-open="toneTuner" id="btnToneTuner">
            <div class="left">
              <div class="icon">
                <svg viewBox="0 0 24 24" fill="none"><path d="M4 10v4" stroke="white" opacity=".9" stroke-width="1.7" stroke-linecap="round"/><path d="M8 7v10" stroke="white" opacity=".9" stroke-width="1.7" stroke-linecap="round"/><path d="M12 4v16" stroke="white" opacity=".9" stroke-width="1.7" stroke-linecap="round"/><path d="M16 7v10" stroke="white" opacity=".9" stroke-width="1.7" stroke-linecap="round"/><path d="M20 10v4" stroke="white" opacity=".9" stroke-width="1.7" stroke-linecap="round"/></svg>
              </div>
              <div>
                <div class="label">Tone</div>
                <div class="sublabel">Pitch-to-control</div>
              </div>
            </div>
            <div class="right"><span>TUNE</span><span>ALT+T</span></div>
          </button>
        </div>
      </div>
    </div>

    <div class="side-foot">
      <div class="kv"><span>OS Control</span><b id="kvOS">IN-APP</b></div>
      <div class="kv"><span>Hover Click</span><b id="kvHover">ON</b></div>
      <div class="kv"><span>Active Cursor</span><b id="kvCursor">GESTURE</b></div>
    </div>
  </aside>

  <header class="topbar">
    <div class="brand">
      <div class="logo" aria-hidden="true">
        <svg viewBox="0 0 24 24" fill="none">
          <path d="M7 13c3-6 10-6 13 0" stroke="white" stroke-width="2.2" stroke-linecap="round"/>
          <circle cx="12" cy="12" r="2.1" fill="white" opacity=".95"/>
        </svg>
      </div>
      <div>
        <h1>OMConsole</h1>
        <div class="sub">Web Operating Console • Multi-Modal Tuners • Blue/Gold High Gloss</div>
      </div>
    </div>

    <div class="top-actions">
      <div class="pill" title="Camera / mic status">
        <span class="dot" id="dotCam"></span><b>CAM</b>
        <span class="dot" id="dotMic"></span><b>MIC</b>
      </div>
      <div class="pill" title="Control status">
        <span class="dot ok" id="dotCtl"></span><b>CONTROL</b>
      </div>
      <button class="btn ghost" id="btnToggleHover" title="F11">Hover Click</button>
      <button class="btn gold" id="btnToggleOS" title="F12">Toggle OS*</button>
      <div class="pill" title="Local time">
        <b id="clock">--:--:--</b>
      </div>
    </div>
  </header>

  <main class="main">
    <div class="stage">
      <div class="viewport" id="viewport">
        <canvas id="viz"></canvas>

        <!-- Hidden media elements used for processing -->
        <video id="cam" playsinline muted class="hidden"></video>
        <audio id="aud" class="hidden"></audio>
      </div>

      <div class="panel">
        <div class="ph">
          <div class="pt" id="panelTitle">LIVE TELEMETRY</div>
          <div class="ps" id="panelSub">Cursor • Click • Signals</div>
        </div>
        <div class="pc" id="panelContent">
          <!-- Dynamic cards inserted by JS -->
        </div>
      </div>
    </div>

    <!-- Modals -->
    <div class="modal" id="modal">
      <div class="sheet" role="dialog" aria-modal="true">
        <div class="sh">
          <div class="ttl" id="modalTitle">Tuner</div>
          <div class="row" style="gap:8px; justify-content:flex-end">
            <button class="smallbtn ghost" id="modalBack">Back</button>
            <button class="smallbtn gold" id="modalSave">Save & Activate</button>
          </div>
        </div>
        <div class="sb" id="modalBody">
          <!-- Two-column content -->
        </div>
      </div>
    </div>
  </main>
</div>

<div id="cursor"></div>

<script type="module">
/**
 * OMConsole Web
 * A high-gloss, blue/gold operating console with:
 * - Gesture cursor (MediaPipe Hands)
 * - Retina cursor (MediaPipe FaceMesh + Iris landmarks)
 * - Tone controller (WebAudio pitch)
 * - EMG/EEG controllers (SIM + WebSerial optional)
 * - Apps: Notepad, Audio Recorder, Video Recorder, Calendar, Games
 *
 * IMPORTANT LIMITATION:
 * Browsers cannot take full OS mouse control for security reasons.
 * "OS Control" toggle here means "In-app cursor automation across this console UI."
 */

// -----------------------------
// Utilities
// -----------------------------
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const lerp = (a, b, t) => a + (b - a) * t;
const fmt = (n, d=2) => Number.isFinite(n) ? n.toFixed(d) : "--";
const nowMs = () => performance.now();

class RollingMean {
  constructor(windowSize=6){
    this.windowSize = Math.max(1, windowSize|0);
    this.values = [];
  }
  setWindowSize(n){
    this.windowSize = Math.max(1, n|0);
    if(this.values.length > this.windowSize){
      this.values = this.values.slice(-this.windowSize);
    }
  }
  push(v){
    this.values.push(v);
    if(this.values.length > this.windowSize) this.values.shift();
    const s = this.values.reduce((acc, x)=>acc + x, 0);
    return s / this.values.length;
  }
}

class Deque {
  constructor(maxlen=200){
    this.maxlen = maxlen;
    this.arr = [];
  }
  push(v){
    this.arr.push(v);
    if(this.arr.length > this.maxlen) this.arr.shift();
  }
  toArray(){ return this.arr.slice(); }
}

function el(tag, attrs={}, children=[]){
  const e = document.createElement(tag);
  for(const [k,v] of Object.entries(attrs)){
    if(k === "class") e.className = v;
    else if(k === "html") e.innerHTML = v;
    else if(k.startsWith("on") && typeof v === "function") e.addEventListener(k.slice(2), v);
    else e.setAttribute(k, v);
  }
  for(const c of children){
    if(typeof c === "string") e.appendChild(document.createTextNode(c));
    else if(c) e.appendChild(c);
  }
  return e;
}

function downloadBlob(blob, filename){
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 2000);
}

// -----------------------------
// Global State + Storage
// -----------------------------
const STORAGE_KEY = "omconsole.web.settings.v1";
const defaultSettings = {
  ui: {
    hoverClick: true,
    hoverTime: 550, // ms
    osMode: "IN_APP" // can't do OS-level; toggle kept for parity
  },
  active: {
    cursorControl: "Gesture" // Gesture | Retina | Tone | EMG | EEG
  },
  gesture: {
    enabled: true,
    simMode: false,
    pinchThreshold: 0.055,
    smoothing: 6
  },
  retina: {
    enabled: false,
    simMode: false,
    sensitivity: 1.6,
    offsetX: 0,
    offsetY: 0,
    invertX: false,
    invertY: false,
    gridSize: 48,
    smoothing: 8,
    showGrid: true
  },
  tone: {
    enabled: false,
    simMode: false,
    toleranceHz: 45,
    speed: 920, // px/s
    tuned: {
      up: 700,
      down: 500,
      left: 350,
      right: 900
    }
  },
  emg: {
    enabled: false,
    simMode: true,
    sensitivity: 50,
    clickThreshold: 70,
    serial: { enabled: false, baudRate: 115200 }
  },
  eeg: {
    enabled: false,
    simMode: true,
    smoothing: 5,
    moveDistance: 22,
    cooldownMs: 650,
    thr: {
      leftUpper: 0.20,
      leftLower: -0.20,
      rightUpper: 0.20,
      rightLower: -0.20,
      centerUpper: 0.20,
      centerLower: -0.20
    },
    serial: { enabled: false, baudRate: 115200 }
  },
  notepad: {
    lastDoc: "default",
    docs: { "default": "" }
  },
  calendar: {
    bookings: {} // yyyy-mm-dd => {time, text}
  }
};

function loadSettings(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return structuredClone(defaultSettings);
    const data = JSON.parse(raw);
    return deepMerge(structuredClone(defaultSettings), data);
  }catch(e){
    console.warn("Settings load failed:", e);
    return structuredClone(defaultSettings);
  }
}
function saveSettings(){
  localStorage.setItem(STORAGE_KEY, JSON.stringify(state.settings));
}
function deepMerge(base, patch){
  if(typeof patch !== "object" || patch === null) return base;
  for(const [k,v] of Object.entries(patch)){
    if(Array.isArray(v)) base[k] = v.slice();
    else if(typeof v === "object" && v !== null){
      base[k] = deepMerge(base[k] ?? {}, v);
    }else base[k] = v;
  }
  return base;
}

const state = {
  settings: loadSettings(),
  ui: {
    mode: "dashboard", // dashboard | app:<name> | tuner:<name>
    modalOpen: false
  },
  runtime: {
    camReady: false,
    micReady: false,
    lastFrameMs: nowMs(),
    fps: 0,
    osEnabled: true, // "OS" mode (in-app)
    hoverEnabled: true
  },
  cursor: {
    x: 120,
    y: 120,
    vx: 0,
    vy: 0,
    click: false,
    clickEdge: false,
    lastClick: false,
    hoverTarget: null,
    hoverStartMs: 0
  },
  telemetry: {
    gesture: { pinch:false, lm:null, confidence:0 },
    retina: { x:0, y:0, has:false },
    tone: { hz:0, active:false },
    emg: { s1:50, s2:50, s3:0, connected:false },
    eeg: { l:0, r:0, c:0, connected:false }
  }
};

// -----------------------------
// DOM references
// -----------------------------
const $ = (sel) => document.querySelector(sel);
const cursorEl = $("#cursor");
const viz = $("#viz");
const viewportEl = $("#viewport");
const panelTitle = $("#panelTitle");
const panelSub = $("#panelSub");
const panelContent = $("#panelContent");
const badgeMode = $("#badgeMode");
const badgeControl = $("#badgeControl");
const kvOS = $("#kvOS");
const kvHover = $("#kvHover");
const kvCursor = $("#kvCursor");

const dotCam = $("#dotCam");
const dotMic = $("#dotMic");
const dotCtl = $("#dotCtl");
const clockEl = $("#clock");

const modal = $("#modal");
const modalTitle = $("#modalTitle");
const modalBack = $("#modalBack");
const modalSave = $("#modalSave");
const modalBody = $("#modalBody");

const camVideo = $("#cam");

// -----------------------------
// Canvas / HiDPI
// -----------------------------
function resizeCanvas(){
  const rect = viz.getBoundingClientRect();
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  viz.width = Math.floor(rect.width * dpr);
  viz.height = Math.floor(rect.height * dpr);
  const ctx = viz.getContext("2d");
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
window.addEventListener("resize", resizeCanvas);

// -----------------------------
// Control Manager (mixes active systems)
// -----------------------------
class ControlManager{
  constructor(){
    this.active = new Map(); // name -> instance
  }
  setActiveCursor(name){
    state.settings.active.cursorControl = name;
    saveSettings();
    badgeControl.textContent = name.toUpperCase();
    kvCursor.textContent = name.toUpperCase();
  }
  enable(name, enabled){
    const inst = controllers[name];
    if(!inst) return;
    inst.enabled = enabled;
    if(enabled){
      this.active.set(name, inst);
      inst.onEnable?.();
    }else{
      this.active.delete(name);
      inst.onDisable?.();
    }
  }
  async ensure(name){
    // make sure controller is enabled and started
    const inst = controllers[name];
    if(!inst) return;
    if(!this.active.has(name)){
      this.enable(name, true);
    }
    await inst.ensureReady?.();
  }
  async activateAsCursor(name){
    await this.ensure(name);
    for(const [k,inst] of this.active.entries()){
      if(k !== name && inst.exclusiveCursor){
        // allow others to remain enabled for telemetry, but cursor routing uses selected control
      }
    }
    this.setActiveCursor(name);
  }
  update(dt){
    let dx = 0, dy = 0, click = false, setPos = null;
    const cursorControl = state.settings.active.cursorControl;

    // Update all active controllers, but only cursorControl drives cursor position/delta
    for(const [name, inst] of this.active.entries()){
      const out = inst.update(dt) || {};
      // update telemetry is done inside each controller
      if(name === cursorControl){
        if(out.setPos) setPos = out.setPos;
        dx += out.dx || 0;
        dy += out.dy || 0;
        click = click || !!out.click;
      }
    }
    return {dx, dy, click, setPos};
  }
}
const controlManager = new ControlManager();

// -----------------------------
// Media: Camera Access
// -----------------------------
let cameraStream = null;
async function ensureCamera(){
  if(cameraStream) return cameraStream;
  try{
    cameraStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" }, audio: false });
    camVideo.srcObject = cameraStream;
    await camVideo.play();
    state.runtime.camReady = true;
    dotCam.classList.add("ok"); dotCam.classList.remove("bad");
    return cameraStream;
  }catch(e){
    console.warn("Camera permission denied / failed:", e);
    state.runtime.camReady = false;
    dotCam.classList.add("bad"); dotCam.classList.remove("ok");
    throw e;
  }
}

// -----------------------------
// Gesture Controller (MediaPipe Hands)
// -----------------------------
class GestureController{
  constructor(){
    this.enabled = false;
    this.exclusiveCursor = true;
    this.hands = null;
    this.camera = null;
    this.ready = false;
    this.lastPos = {x: state.cursor.x, y: state.cursor.y};
    this.xf = new RollingMean(state.settings.gesture.smoothing);
    this.yf = new RollingMean(state.settings.gesture.smoothing);
    this.lastPinch = false;
    this.pinchEdge = false;
  }
  async ensureReady(){
    if(this.ready) return;
    if(state.settings.gesture.simMode){
      this.ready = true;
      return;
    }
    await ensureCamera();
    await this.initHands();
    this.ready = true;
  }
  async initHands(){
    // wait for MediaPipe to load
    await waitForGlobal("Hands");
    await waitForGlobal("Camera");
    this.hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
    this.hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.5
    });
    this.hands.onResults((res)=>this.onResults(res));

    this.camera = new Camera(camVideo, {
      onFrame: async () => { if(this.enabled) await this.hands.send({image: camVideo}); },
      width: 640,
      height: 480
    });
    this.camera.start();
  }
  onEnable(){
    this.xf.setWindowSize(state.settings.gesture.smoothing);
    this.yf.setWindowSize(state.settings.gesture.smoothing);
  }
  onDisable(){}
  onResults(results){
    const lm = results.multiHandLandmarks?.[0];
    state.telemetry.gesture.lm = lm || null;
    state.telemetry.gesture.confidence = lm ? 1 : 0;

    if(!lm) {
      state.telemetry.gesture.pinch = false;
      this.pinchEdge = false;
      this.lastPinch = false;
      return;
    }
    const idx = lm[8]; // index tip
    const th = lm[4];  // thumb tip
    const dx = idx.x - th.x, dy = idx.y - th.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const pinch = dist < state.settings.gesture.pinchThreshold;
    state.telemetry.gesture.pinch = pinch;
    this.pinchEdge = pinch && !this.lastPinch;
    this.lastPinch = pinch;

    const w = window.innerWidth, h = window.innerHeight;
    const tx = clamp(idx.x * w, 0, w);
    const ty = clamp(idx.y * h, 0, h);
    const sx = this.xf.push(tx);
    const sy = this.yf.push(ty);
    this.lastPos = {x: sx, y: sy};
  }
  update(dt){
    if(!this.enabled) return {dx:0, dy:0, click:false};

    // SIM: synthetic cursor & pinch
    if(state.settings.gesture.simMode){
      const t = nowMs()/1000;
      const w = window.innerWidth, h = window.innerHeight;
      const tx = w*(0.5 + 0.36*Math.sin(t*0.7));
      const ty = h*(0.5 + 0.32*Math.sin(t*1.0 + 0.6));
      const sx = this.xf.push(tx);
      const sy = this.yf.push(ty);
      const pinch = (Math.sin(t*2.5) > 0.92); // occasional clicks
      state.telemetry.gesture.pinch = pinch;
      state.telemetry.gesture.confidence = 1;
      return { setPos: [sx, sy], click: pinch };
    }

    if(!this.ready) return {dx:0, dy:0, click:false};

    // Set position override from MediaPipe
    const pos = this.lastPos;
    const click = !!state.telemetry.gesture.pinch;
    return { setPos: [pos.x, pos.y], click };
  }
}

// -----------------------------
// Retina Controller (MediaPipe FaceMesh + Iris)
// -----------------------------
class RetinaController{
  constructor(){
    this.enabled = false;
    this.exclusiveCursor = true;
    this.face = null;
    this.camera = null;
    this.ready = false;

    this.xf = new RollingMean(state.settings.retina.smoothing);
    this.yf = new RollingMean(state.settings.retina.smoothing);
    this.lastHas = false;
    this.lastPos = {x: state.cursor.x, y: state.cursor.y};
  }
  async ensureReady(){
    if(this.ready) return;
    if(state.settings.retina.simMode){
      this.ready = true;
      state.telemetry.retina.has = true;
      return;
    }
    await ensureCamera();
    await this.initFace();
    this.ready = true;
  }
  async initFace(){
    await waitForGlobal("FaceMesh");
    await waitForGlobal("Camera");

    this.face = new FaceMesh({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}` });
    this.face.setOptions({
      maxNumFaces: 1,
      refineLandmarks: true,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.6
    });
    this.face.onResults((res)=>this.onResults(res));

    this.camera = new Camera(camVideo, {
      onFrame: async () => { if(this.enabled) await this.face.send({image: camVideo}); },
      width: 640, height: 480
    });
    this.camera.start();
  }
  onEnable(){
    this.xf.setWindowSize(state.settings.retina.smoothing);
    this.yf.setWindowSize(state.settings.retina.smoothing);
  }
  onResults(res){
    const lm = res.multiFaceLandmarks?.[0];
    if(!lm){
      state.telemetry.retina.has = false;
      this.lastHas = false;
      return;
    }

    // Iris landmark indices (refineLandmarks=true). If unavailable in some builds, fallback to eye corners.
    const irisL = [468,469,470,471,472]; // left iris
    const irisR = [473,474,475,476,477]; // right iris
    let ix = 0, iy = 0, count = 0;

    for(const idx of [...irisL, ...irisR]){
      if(lm[idx]){
        ix += lm[idx].x; iy += lm[idx].y; count++;
      }
    }
    if(count === 0){
      // fallback: average of eye corners (approx)
      const fallback = [33, 133, 362, 263]; // eye corners
      for(const idx of fallback){
        if(lm[idx]){
          ix += lm[idx].x; iy += lm[idx].y; count++;
        }
      }
    }
    ix /= count; iy /= count;

    // Map to screen with sensitivity/offset/invert
    const w = window.innerWidth, h = window.innerHeight;
    let x = ix * w;
    let y = iy * h;

    const s = state.settings.retina.sensitivity;
    x = (x - w/2) * s + w/2 + state.settings.retina.offsetX;
    y = (y - h/2) * s + h/2 + state.settings.retina.offsetY;

    if(state.settings.retina.invertX) x = w - x;
    if(state.settings.retina.invertY) y = h - y;

    x = clamp(x, 0, w);
    y = clamp(y, 0, h);

    const sx = this.xf.push(x);
    const sy = this.yf.push(y);

    this.lastPos = {x: sx, y: sy};
    state.telemetry.retina = {x: sx, y: sy, has:true};
  }
  update(dt){
    if(!this.enabled) return {dx:0, dy:0, click:false};

    if(state.settings.retina.simMode){
      const t = nowMs()/1000;
      const w = window.innerWidth, h = window.innerHeight;
      const tx = w*(0.5 + 0.33*Math.sin(t*0.55 + 1.2));
      const ty = h*(0.5 + 0.28*Math.sin(t*0.85 + 2.1));
      const sx = this.xf.push(tx);
      const sy = this.yf.push(ty);
      state.telemetry.retina = {x:sx, y:sy, has:true};
      return { setPos: [sx, sy], click:false };
    }

    if(!this.ready || !state.telemetry.retina.has) return {dx:0, dy:0, click:false};
    return { setPos: [this.lastPos.x, this.lastPos.y], click:false };
  }
}

// -----------------------------
// Tone Controller (WebAudio Pitch)
// -----------------------------
class ToneController{
  constructor(){
    this.enabled = false;
    this.exclusiveCursor = true;
    this.ready = false;

    this.audioCtx = null;
    this.analyser = null;
    this.buf = null;
    this.stream = null;

    this.pitchHz = 0;
    this.smooth = new RollingMean(6);
    this.lastClick = false;
    this.simPhase = 0;

    this.tuning = {
      active: false,
      directionIndex: 0,
      directions: ["up","down","left","right"],
      data: { up: [], down: [], left: [], right: [] }
    };
  }
  async ensureReady(){
    if(this.ready) return;
    try{
      await this.initAudio();
      state.runtime.micReady = true;
      dotMic.classList.add("ok"); dotMic.classList.remove("bad");
    }catch(e){
      // fallback to sim mode
      console.warn("Mic init failed. Using SIM tone mode.", e);
      state.settings.tone.simMode = true;
      saveSettings();
      state.runtime.micReady = false;
      dotMic.classList.add("bad"); dotMic.classList.remove("ok");
    }
    this.ready = true;
  }
  async initAudio(){
    // Must be called from a user gesture in many browsers.
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video:false });
    this.stream = stream;
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    this.audioCtx = new AudioContext();
    const src = this.audioCtx.createMediaStreamSource(stream);
    this.analyser = this.audioCtx.createAnalyser();
    this.analyser.fftSize = 2048;
    src.connect(this.analyser);
    this.buf = new Float32Array(this.analyser.fftSize);
  }
  startTuning(){
    this.tuning.active = true;
    this.tuning.directionIndex = 0;
    this.tuning.data = { up: [], down: [], left: [], right: [] };
  }
  acceptTone(){
    const dir = this.tuning.directions[this.tuning.directionIndex];
    if(!dir) return;
    const hz = this.pitchHz;
    if(hz > 0){
      this.tuning.data[dir].push(hz);
      const avg = this.tuning.data[dir].reduce((a,b)=>a+b,0) / this.tuning.data[dir].length;
      state.settings.tone.tuned[dir] = Math.round(avg);
      saveSettings();
    }
    this.tuning.directionIndex++;
    if(this.tuning.directionIndex >= this.tuning.directions.length){
      this.tuning.active = false;
    }
  }
  update(dt){
    if(!this.enabled || !this.ready) return {dx:0, dy:0, click:false};

    // Get pitch (real or SIM)
    let hz = 0;
    if(state.settings.tone.simMode || !this.analyser){
      this.simPhase += dt * 0.001;
      // Oscillate between tuned tones
      const tones = Object.values(state.settings.tone.tuned);
      const idx = Math.floor((Math.sin(this.simPhase*0.9)+1)/2 * tones.length) % tones.length;
      hz = tones[idx] + (Math.sin(this.simPhase*3.2)*12);
    }else{
      this.analyser.getFloatTimeDomainData(this.buf);
      hz = autoCorrelate(this.buf, this.audioCtx.sampleRate);
    }

    if(hz && hz > 0){
      this.pitchHz = this.smooth.push(hz);
      state.telemetry.tone = { hz: this.pitchHz, active:true };
    }else{
      this.pitchHz = 0;
      state.telemetry.tone = { hz: 0, active:false };
    }

    // Use tuned discrete tones to decide direction
    const tuned = state.settings.tone.tuned;
    const tol = state.settings.tone.toleranceHz;
    const spd = state.settings.tone.speed; // px/s

    let dx = 0, dy = 0;
    if(this.pitchHz > 0){
      const candidates = [
        ["up", tuned.up],
        ["down", tuned.down],
        ["left", tuned.left],
        ["right", tuned.right]
      ];
      let best = null, bestDiff = Infinity;
      for(const [dir, target] of candidates){
        const diff = Math.abs(this.pitchHz - target);
        if(diff < bestDiff){ bestDiff = diff; best = dir; }
      }
      if(bestDiff <= tol){
        const step = spd * (dt/1000);
        if(best === "up") dy -= step;
        if(best === "down") dy += step;
        if(best === "left") dx -= step;
        if(best === "right") dx += step;
      }
    }

    // no click for tone by default
    return {dx, dy, click:false};
  }
}

// Standard autocorrelation pitch detection
function autoCorrelate(buf, sampleRate){
  // buf is Float32Array time-domain audio
  const SIZE = buf.length;
  let rms = 0;
  for (let i=0; i<SIZE; i++) { const v = buf[i]; rms += v*v; }
  rms = Math.sqrt(rms / SIZE);
  if (rms < 0.01) return 0;

  // Trim leading/trailing silence
  let r1 = 0, r2 = SIZE-1, thres = 0.2;
  for (let i=0; i<SIZE/2; i++){
    if (Math.abs(buf[i]) < thres) { r1 = i; break; }
  }
  for (let i=1; i<SIZE/2; i++){
    if (Math.abs(buf[SIZE-i]) < thres) { r2 = SIZE-i; break; }
  }
  buf = buf.slice(r1, r2);
  const newSize = buf.length;

  const c = new Array(newSize).fill(0);
  for (let i=0; i<newSize; i++){
    for (let j=0; j<newSize-i; j++){
      c[i] = c[i] + buf[j]*buf[j+i];
    }
  }

  let d = 0;
  while (c[d] > c[d+1]) d++;
  let maxval = -1, maxpos = -1;
  for (let i=d; i<newSize; i++){
    if (c[i] > maxval){ maxval = c[i]; maxpos = i; }
  }
  let T0 = maxpos;

  // parabolic interpolation
  const x1 = c[T0-1], x2 = c[T0], x3 = c[T0+1];
  const a = (x1 + x3 - 2*x2) / 2;
  const b = (x3 - x1) / 2;
  if (a) T0 = T0 - b/(2*a);

  const freq = sampleRate / T0;
  if(!Number.isFinite(freq) || freq < 50 || freq > 2000) return 0;
  return freq;
}

// -----------------------------
// EMG Controller (SIM + WebSerial)
// -----------------------------
class EMGController{
  constructor(){
    this.enabled = false;
    this.exclusiveCursor = true;
    this.ready = true; // SIM ready immediately
    this.connected = false;
    this.serialPort = null;
    this.reader = null;

    this.hist1 = new Deque(160);
    this.hist2 = new Deque(160);
    this.hist3 = new Deque(160);
  }
  async ensureReady(){ return; }

  async connectSerial(){
    if(!("serial" in navigator)){
      alert("WebSerial is not supported in this browser. Use Chrome/Edge over HTTPS.");
      return;
    }
    try{
      this.serialPort = await navigator.serial.requestPort();
      await this.serialPort.open({ baudRate: state.settings.emg.serial.baudRate });
      this.connected = true;
      state.telemetry.emg.connected = true;
      this.reader = this.serialPort.readable.getReader();
      this.readLoop();
    }catch(e){
      console.warn("EMG serial connect failed:", e);
      this.connected = false;
      state.telemetry.emg.connected = false;
    }
  }
  async disconnectSerial(){
    try{
      if(this.reader){ await this.reader.cancel(); this.reader.releaseLock(); this.reader = null; }
      if(this.serialPort){ await this.serialPort.close(); this.serialPort = null; }
    }catch(e){}
    this.connected = false;
    state.telemetry.emg.connected = false;
  }
  async readLoop(){
    let buf = "";
    while(this.connected && this.reader){
      const { value, done } = await this.reader.read();
      if(done) break;
      if(value){
        buf += new TextDecoder().decode(value);
        let lines = buf.split("\n");
        buf = lines.pop() || "";
        for(const line of lines){
          this.parseLine(line.trim());
        }
      }
    }
  }
  parseLine(line){
    // Accept JSON: {"s1":..,"s2":..,"s3":..} OR CSV: s1,s2,s3
    try{
      if(!line) return;
      if(line.startsWith("{")){
        const o = JSON.parse(line);
        state.telemetry.emg.s1 = clamp(Number(o.s1 ?? o.sensor1 ?? 50), 0, 100);
        state.telemetry.emg.s2 = clamp(Number(o.s2 ?? o.sensor2 ?? 50), 0, 100);
        state.telemetry.emg.s3 = clamp(Number(o.s3 ?? o.sensor3 ?? 0), 0, 100);
      }else{
        const parts = line.split(",").map(x=>Number(x.trim()));
        if(parts.length >= 3){
          state.telemetry.emg.s1 = clamp(parts[0], 0, 100);
          state.telemetry.emg.s2 = clamp(parts[1], 0, 100);
          state.telemetry.emg.s3 = clamp(parts[2], 0, 100);
        }
      }
    }catch(e){}
  }

  update(dt){
    if(!this.enabled) return {dx:0, dy:0, click:false};

    let s1, s2, s3;
    if(state.settings.emg.simMode || !this.connected){
      // SIM: mild random walk
      const t = nowMs()/1000;
      s1 = 50 + Math.sin(t*1.2)*22 + (Math.random()-0.5)*8;
      s2 = 50 + Math.cos(t*1.0)*22 + (Math.random()-0.5)*8;
      s3 = 50 + Math.sin(t*1.8)*30 + (Math.random()-0.5)*10;
      s1 = clamp(s1, 0, 100); s2 = clamp(s2, 0, 100); s3 = clamp(s3, 0, 100);
      state.telemetry.emg = { s1, s2, s3, connected:false };
    }else{
      ({s1, s2, s3} = state.telemetry.emg);
    }

    this.hist1.push(s1); this.hist2.push(s2); this.hist3.push(s3);

    const sens = state.settings.emg.sensitivity;
    const dx = ((s1 - 50) / 50) * (sens/50) * 900 * (dt/1000);
    const dy = ((s2 - 50) / 50) * (sens/50) * 900 * (dt/1000);
    const click = s3 >= state.settings.emg.clickThreshold;

    return {dx, dy, click};
  }
}

// -----------------------------
// EEG Controller (SIM + WebSerial)
// -----------------------------
class EEGController{
  constructor(){
    this.enabled = false;
    this.exclusiveCursor = true;
    this.ready = true;
    this.connected = false;
    this.serialPort = null;
    this.reader = null;

    this.histL = new Deque(220);
    this.histR = new Deque(220);
    this.histC = new Deque(220);

    this.lastActionMs = 0;
  }
  async ensureReady(){ return; }

  async connectSerial(){
    if(!("serial" in navigator)){
      alert("WebSerial is not supported in this browser. Use Chrome/Edge over HTTPS.");
      return;
    }
    try{
      this.serialPort = await navigator.serial.requestPort();
      await this.serialPort.open({ baudRate: state.settings.eeg.serial.baudRate });
      this.connected = true;
      state.telemetry.eeg.connected = true;
      this.reader = this.serialPort.readable.getReader();
      this.readLoop();
    }catch(e){
      console.warn("EEG serial connect failed:", e);
      this.connected = false;
      state.telemetry.eeg.connected = false;
    }
  }
  async disconnectSerial(){
    try{
      if(this.reader){ await this.reader.cancel(); this.reader.releaseLock(); this.reader = null; }
      if(this.serialPort){ await this.serialPort.close(); this.serialPort = null; }
    }catch(e){}
    this.connected = false;
    state.telemetry.eeg.connected = false;
  }
  async readLoop(){
    let buf = "";
    while(this.connected && this.reader){
      const { value, done } = await this.reader.read();
      if(done) break;
      if(value){
        buf += new TextDecoder().decode(value);
        let lines = buf.split("\n");
        buf = lines.pop() || "";
        for(const line of lines){
          this.parseLine(line.trim());
        }
      }
    }
  }
  parseLine(line){
    // JSON {"l":..,"r":..,"c":..} in [-1,1] or CSV
    try{
      if(!line) return;
      if(line.startsWith("{")){
        const o = JSON.parse(line);
        state.telemetry.eeg.l = clamp(Number(o.l ?? o.left ?? 0), -1, 1);
        state.telemetry.eeg.r = clamp(Number(o.r ?? o.right ?? 0), -1, 1);
        state.telemetry.eeg.c = clamp(Number(o.c ?? o.center ?? 0), -1, 1);
      }else{
        const parts = line.split(",").map(x=>Number(x.trim()));
        if(parts.length >= 3){
          state.telemetry.eeg.l = clamp(parts[0], -1, 1);
          state.telemetry.eeg.r = clamp(parts[1], -1, 1);
          state.telemetry.eeg.c = clamp(parts[2], -1, 1);
        }
      }
    }catch(e){}
  }

  update(dt){
    if(!this.enabled) return {dx:0, dy:0, click:false};

    let l, r, c;
    if(state.settings.eeg.simMode || !this.connected){
      const t = nowMs()/1000;
      l = Math.sin(t*1.1)*0.28 + (Math.random()-0.5)*0.12;
      r = Math.cos(t*1.0)*0.28 + (Math.random()-0.5)*0.12;
      c = Math.sin(t*0.8)*0.22 + (Math.random()-0.5)*0.10;
      l = clamp(l, -1, 1); r = clamp(r, -1, 1); c = clamp(c, -1, 1);
      state.telemetry.eeg = { l, r, c, connected:false };
    }else{
      ({l, r, c} = state.telemetry.eeg);
    }

    this.histL.push(l); this.histR.push(r); this.histC.push(c);

    // Decide direction based on thresholds and smoothing
    const thr = state.settings.eeg.thr;
    const move = state.settings.eeg.moveDistance; // px per action
    const cooldown = state.settings.eeg.cooldownMs;

    const tNow = nowMs();
    let dx = 0, dy = 0, click = false;
    if(tNow - this.lastActionMs >= cooldown){
      if(l > thr.leftUpper) dx += move;
      else if(l < thr.leftLower) dx -= move;

      if(r > thr.rightUpper) dy += move;
      else if(r < thr.rightLower) dy -= move;

      if(c > thr.centerUpper || c < thr.centerLower) click = true;

      if(dx !== 0 || dy !== 0 || click){
        this.lastActionMs = tNow;
      }
    }

    return {dx, dy, click};
  }
}

// -----------------------------
// App Modules
// -----------------------------
class NotepadApp{
  constructor(){
    this.name = "notepad";
    this.text = state.settings.notepad.docs[state.settings.notepad.lastDoc] ?? "";
    this.docName = state.settings.notepad.lastDoc || "default";
  }
  open(){
    setMode("app:notepad");
    panelTitle.textContent = "NOTEPAD";
    panelSub.textContent = "LocalStorage • On-Screen Keyboard";
    renderPanel_Notepad();
  }
}

class AudioApp{
  constructor(){
    this.rec = null;
    this.chunks = [];
    this.blob = null;
    this.url = null;
    this.stream = null;
    this.recording = false;
  }
  open(){
    setMode("app:audio");
    panelTitle.textContent = "AUDIO";
    panelSub.textContent = "MediaRecorder • Record/Play/Download";
    renderPanel_Audio();
  }
  async ensureStream(){
    if(this.stream) return;
    this.stream = await navigator.mediaDevices.getUserMedia({ audio:true, video:false });
    state.runtime.micReady = true;
    dotMic.classList.add("ok"); dotMic.classList.remove("bad");
  }
  async start(){
    await this.ensureStream();
    this.chunks = [];
    this.rec = new MediaRecorder(this.stream);
    this.rec.ondataavailable = (e)=>{ if(e.data.size>0) this.chunks.push(e.data); };
    this.rec.onstop = ()=>{
      this.blob = new Blob(this.chunks, {type: this.rec.mimeType || "audio/webm"});
      if(this.url) URL.revokeObjectURL(this.url);
      this.url = URL.createObjectURL(this.blob);
      $("#audioPlayback").src = this.url;
      this.recording = false;
      renderPanel_Audio();
    };
    this.rec.start();
    this.recording = true;
    renderPanel_Audio();
  }
  stop(){
    if(this.rec && this.recording){
      this.rec.stop();
    }
  }
  download(){
    if(this.blob) downloadBlob(this.blob, `omconsole_audio_${Date.now()}.webm`);
  }
}

class VideoApp{
  constructor(){
    this.stream = null;
    this.rec = null;
    this.chunks = [];
    this.blob = null;
    this.url = null;
    this.recording = false;
    this.previewOn = false;
  }
  open(){
    setMode("app:video");
    panelTitle.textContent = "VIDEO";
    panelSub.textContent = "MediaRecorder • Record/Preview/Download";
    renderPanel_Video();
  }
  async ensureStream(){
    if(this.stream) return;
    this.stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:"user" }, audio:true });
    state.runtime.camReady = true;
    dotCam.classList.add("ok"); dotCam.classList.remove("bad");
    state.runtime.micReady = true;
    dotMic.classList.add("ok"); dotMic.classList.remove("bad");
  }
  async start(){
    await this.ensureStream();
    this.chunks = [];
    this.rec = new MediaRecorder(this.stream);
    this.rec.ondataavailable = (e)=>{ if(e.data.size>0) this.chunks.push(e.data); };
    this.rec.onstop = ()=>{
      this.blob = new Blob(this.chunks, {type: this.rec.mimeType || "video/webm"});
      if(this.url) URL.revokeObjectURL(this.url);
      this.url = URL.createObjectURL(this.blob);
      $("#videoPlayback").src = this.url;
      this.recording = false;
      renderPanel_Video();
    };
    this.rec.start();
    this.recording = true;
    // auto-stop after 10s like desktop app
    setTimeout(()=>{ if(this.recording) this.stop(); }, 10000);
    renderPanel_Video();
  }
  stop(){
    if(this.rec && this.recording){
      this.rec.stop();
    }
  }
  togglePreview(){
    this.previewOn = !this.previewOn;
    if(this.previewOn){
      this.ensureStream().then(()=>{
        const v = $("#videoPreview");
        v.srcObject = this.stream;
        v.play();
        renderPanel_Video();
      });
    }else{
      const v = $("#videoPreview");
      if(v) v.pause();
      renderPanel_Video();
    }
  }
  download(){
    if(this.blob) downloadBlob(this.blob, `omconsole_video_${Date.now()}.webm`);
  }
}

class CalendarApp{
  constructor(){}
  open(){
    setMode("app:calendar");
    panelTitle.textContent = "CALENDAR";
    panelSub.textContent = "Bookings • Time Slots • LocalStorage";
    renderPanel_Calendar();
  }
}

class GamesApp{
  constructor(){
    this.pong = new PongGame();
  }
  open(){
    setMode("app:games");
    panelTitle.textContent = "GAMES";
    panelSub.textContent = "Built-in Pong • Cursor to play";
    renderPanel_Games();
  }
}

class PongGame{
  constructor(){
    this.active = false;
    this.ball = {x: 0.5, y: 0.5, vx: 0.38, vy: 0.26};
    this.p1 = {y: 0.5};
    this.p2 = {y: 0.5};
    this.score = {a:0,b:0};
  }
  reset(){
    this.ball = {x: 0.5, y: 0.5, vx: (Math.random()>0.5?1:-1)*0.42, vy: (Math.random()>0.5?1:-1)*0.25};
  }
  update(dt){
    if(!this.active) return;
    const t = dt/1000;
    this.ball.x += this.ball.vx * t;
    this.ball.y += this.ball.vy * t;

    // cursor controls left paddle
    const h = window.innerHeight;
    this.p1.y = clamp(state.cursor.y / h, 0, 1);

    // AI right paddle
    this.p2.y = lerp(this.p2.y, this.ball.y, 0.07);

    // bounds
    if(this.ball.y < 0.02){ this.ball.y = 0.02; this.ball.vy *= -1; }
    if(this.ball.y > 0.98){ this.ball.y = 0.98; this.ball.vy *= -1; }

    // paddle collisions
    const paddleH = 0.18;
    const p1x = 0.07, p2x = 0.93;
    const collidePaddle = (px, py) => {
      const bx = this.ball.x, by = this.ball.y;
      const dx = Math.abs(bx - px);
      const dy = Math.abs(by - py);
      if(dx < 0.02 && dy < paddleH/2){
        const angle = (by - py) * 3.2;
        this.ball.vy = clamp(this.ball.vy + angle*0.25, -0.7, 0.7);
        this.ball.vx *= -1;
        // speed up slightly
        this.ball.vx *= 1.03;
        this.ball.vy *= 1.02;
      }
    };
    collidePaddle(p1x, this.p1.y);
    collidePaddle(p2x, this.p2.y);

    // scoring
    if(this.ball.x < -0.02){ this.score.b++; this.reset(); }
    if(this.ball.x > 1.02){ this.score.a++; this.reset(); }
  }
  draw(ctx, w, h){
    if(!this.active) return;
    // field
    ctx.save();
    ctx.globalAlpha = 0.92;
    ctx.strokeStyle = "rgba(242,213,122,.45)";
    ctx.lineWidth = 2;
    ctx.setLineDash([8,8]);
    ctx.beginPath();
    ctx.moveTo(w/2, 20);
    ctx.lineTo(w/2, h-20);
    ctx.stroke();
    ctx.setLineDash([]);

    // paddles
    const paddleH = h*0.18;
    const paddleW = 14;
    ctx.fillStyle = "rgba(234,242,255,.82)";
    ctx.fillRect(w*0.07 - paddleW/2, h*this.p1.y - paddleH/2, paddleW, paddleH);
    ctx.fillRect(w*0.93 - paddleW/2, h*this.p2.y - paddleH/2, paddleW, paddleH);

    // ball
    ctx.fillStyle = "rgba(212,175,55,.95)";
    ctx.beginPath();
    ctx.arc(w*this.ball.x, h*this.ball.y, 10, 0, Math.PI*2);
    ctx.fill();

    // score
    ctx.fillStyle = "rgba(234,242,255,.85)";
    ctx.font = "800 26px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
    ctx.textAlign = "center";
    ctx.fillText(`${this.score.a}  :  ${this.score.b}`, w/2, 52);
    ctx.restore();
  }
}

// -----------------------------
// Tuners: open in modal
// -----------------------------
function openModal(title, bodyLeft, bodyRight, onSave){
  modalTitle.textContent = title;
  modalBody.innerHTML = "";
  const left = el("div", {class:"left"}, bodyLeft);
  const right = el("div", {class:"right"}, bodyRight);
  modalBody.append(left, right);

  modal.classList.add("show");
  state.ui.modalOpen = true;

  modalBack.onclick = ()=>closeModal();
  modalSave.onclick = async ()=>{
    await onSave?.();
    closeModal();
  };
}
function closeModal(){
  modal.classList.remove("show");
  state.ui.modalOpen = false;
  setMode("dashboard");
}


function tuner_Gesture(){
  const s = state.settings.gesture;
  const left = [
    makeCard("Hand Tracking", [
      el("div",{class:"hint"},[
        "Gesture control uses MediaPipe Hands. Cursor is driven by index fingertip; click uses a pinch (thumb+index). ",
        "You can run SIM mode to test without camera."
      ]),
      el("div",{class:"row"},[
        el("button",{class:"smallbtn", id:"gesStart"},["Start / Resume"]),
        el("button",{class:"smallbtn ghost", id:"gesToggleSim"},[s.simMode ? "SIM: ON":"SIM: OFF"]),
      ])
    ]),
    makeCard("Parameters", [
      slider("Pinch Threshold", 0.02, 0.12, 0.001, s.pinchThreshold, (v)=>{ s.pinchThreshold = v; saveSettings(); }),
      slider("Smoothing", 1, 20, 1, s.smoothing, (v)=>{ s.smoothing = v|0; controllers.Gesture.xf.setWindowSize(s.smoothing); controllers.Gesture.yf.setWindowSize(s.smoothing); saveSettings(); }),
    ])
  ];

  const right = [
    makeCard("Live", [
      el("div",{class:"hint", id:"gesLive"},["Waiting…"]),
      el("div",{class:"kv2"},[el("span",{},["Pinch"]), el("b",{id:"gesPinch"},["--"])]),
      el("div",{class:"kv2"},[el("span",{},["Cursor"]), el("b",{id:"gesPos"},["--"])]),
      el("div",{class:"kv2"},[el("span",{},["Camera"]), el("b",{id:"gesCam"},["--"])]),
    ]),
    makeCard("Notes", [
      el("div",{class:"hint"},[
        "If tracking feels jittery, increase smoothing.\n",
        "If clicks trigger too easily, lower pinch threshold."
      ])
    ])
  ];

  openModal("Gesture Tuner", left, right, async ()=>{
    await controlManager.activateAsCursor("Gesture");
    controlManager.enable("Gesture", true);
    state.settings.gesture.enabled = true;
    saveSettings();
  });

  $("#gesStart").onclick = async ()=>{
    await controlManager.ensure("Gesture");
    state.settings.gesture.enabled = true;
    saveSettings();
  };
  $("#gesToggleSim").onclick = ()=>{
    s.simMode = !s.simMode; saveSettings();
    $("#gesToggleSim").textContent = s.simMode ? "SIM: ON":"SIM: OFF";
    if(s.simMode){
      // allow immediate without camera
      controllers.Gesture.ready = true;
    }else{
      controllers.Gesture.ready = false;
      state.telemetry.gesture.pinch = false;
    }
  };
}

function tuner_Retina(){
  const s = state.settings.retina;
  const left = [
    makeCard("Retina Tracking", [
      el("div",{class:"hint"},[
        "Uses MediaPipe FaceMesh + Iris landmarks to estimate gaze point. ",
        "Tune sensitivity/offset/smoothing, then Save & Activate."
      ]),
      el("div",{class:"row"},[
        el("button",{class:"smallbtn", id:"retinaStart"},["Start / Resume"]),
        el("button",{class:"smallbtn ghost", id:"retinaToggleSim"},[s.simMode ? "SIM: ON":"SIM: OFF"]),
        el("button",{class:"smallbtn ghost", id:"retinaToggleGrid"},[s.showGrid ? "Grid: ON":"Grid: OFF"]),
        el("button",{class:"smallbtn ghost", id:"retinaInvertX"},[s.invertX ? "Invert X: ON":"Invert X: OFF"]),
        el("button",{class:"smallbtn ghost", id:"retinaInvertY"},[s.invertY ? "Invert Y: ON":"Invert Y: OFF"]),
      ])
    ]),
    makeCard("Calibration", [
      slider("Sensitivity", 0.6, 3.0, 0.01, s.sensitivity, (v)=>{ s.sensitivity = v; saveSettings(); }),
      slider("Offset X", -600, 600, 1, s.offsetX, (v)=>{ s.offsetX = v; saveSettings(); }),
      slider("Offset Y", -400, 400, 1, s.offsetY, (v)=>{ s.offsetY = v; saveSettings(); }),
      slider("Smoothing", 1, 20, 1, s.smoothing, (v)=>{ s.smoothing = v; controllers.Retina.xf.setWindowSize(v); controllers.Retina.yf.setWindowSize(v); saveSettings(); }),
      slider("Grid Size", 18, 120, 1, s.gridSize, (v)=>{ s.gridSize = v|0; saveSettings(); }),
    ])
  ];

  const right = [
    makeCard("Live", [
      el("div",{class:"hint", id:"retinaLive"},["Waiting for camera…"]),
      el("div",{class:"kv2"},[
        el("span",{},["Has Face"]),
        el("b",{id:"retinaHas"},["--"])
      ]),
      el("div",{class:"kv2"},[
        el("span",{},["X"]),
        el("b",{id:"retinaX"},["--"])
      ]),
      el("div",{class:"kv2"},[
        el("span",{},["Y"]),
        el("b",{id:"retinaY"},["--"])
      ]),
    ]),
    makeCard("Cursor", [
      el("div",{class:"hint"},["Retina is a direct cursor source. Use Control Selector to assign it to Cursor, then Save here to activate settings."])
    ])
  ];

  openModal("Retina Tuner", left, right, async ()=>{
    // Activate retina as cursor
    await controlManager.activateAsCursor("Retina");
    controlManager.enable("Retina", true);
    state.settings.retina.enabled = true;
    saveSettings();
  });

  // wire buttons
  $("#retinaStart").onclick = async ()=>{
    await controlManager.ensure("Retina");
    state.settings.retina.enabled = true;
    saveSettings();
  };
  $("#retinaToggleSim").onclick = ()=>{
    s.simMode = !s.simMode;
    saveSettings();
    $("#retinaToggleSim").textContent = s.simMode ? "SIM: ON":"SIM: OFF";
    if(s.simMode){
      controllers.Retina.ready = true;
      state.telemetry.retina.has = true;
    }else{
      controllers.Retina.ready = false;
      state.telemetry.retina.has = false;
    }
  };
  $("#retinaToggleGrid").onclick = ()=>{
    s.showGrid = !s.showGrid; saveSettings();
    $("#retinaToggleGrid").textContent = s.showGrid ? "Grid: ON":"Grid: OFF";
  };
  $("#retinaInvertX").onclick = ()=>{
    s.invertX = !s.invertX; saveSettings();
    $("#retinaInvertX").textContent = s.invertX ? "Invert X: ON":"Invert X: OFF";
  };
  $("#retinaInvertY").onclick = ()=>{
    s.invertY = !s.invertY; saveSettings();
    $("#retinaInvertY").textContent = s.invertY ? "Invert Y: ON":"Invert Y: OFF";
  };
}

function tuner_EMG(){
  const s = state.settings.emg;
  const left = [
    makeCard("EMG Input", [
      el("div",{class:"hint"},[
        "EMG has 3 channels: sensor1 (X), sensor2 (Y), sensor3 (Click). ",
        "SIM mode generates signals if no hardware connected."
      ]),
      el("div",{class:"row"},[
        el("button",{class:"smallbtn", id:"emgStart"},["Start (SIM)"]),
        el("button",{class:"smallbtn ghost", id:"emgToggleSim"},[s.simMode ? "SIM: ON":"SIM: OFF"]),
        el("button",{class:"smallbtn ghost", id:"emgConnect"},["Connect WebSerial"]),
        el("button",{class:"smallbtn danger", id:"emgDisconnect"},["Disconnect"])
      ]),
    ]),
    makeCard("Controls", [
      slider("Sensitivity", 0, 100, 1, s.sensitivity, (v)=>{ s.sensitivity = v; saveSettings(); }),
      slider("Click Threshold", 0, 100, 1, s.clickThreshold, (v)=>{ s.clickThreshold = v; saveSettings(); }),
      slider("WebSerial Baud", 9600, 230400, 1, s.serial.baudRate, (v)=>{ s.serial.baudRate = v|0; saveSettings(); })
    ])
  ];
  const right = [
    makeCard("Live Channels", [
      el("div",{class:"hint", id:"emgLive"},["SIM running."]),
      sparkline("Sensor1 (X)", "emgSpark1"),
      sparkline("Sensor2 (Y)", "emgSpark2"),
      sparkline("Sensor3 (Click)", "emgSpark3"),
      el("div",{class:"kv2"},[el("span",{},["Connected"]), el("b",{id:"emgConn"},["--"])]),
    ]),
    makeCard("Data Format", [
      el("div",{class:"hint"},[
        "WebSerial accepts:\n",
        "\n• CSV: s1,s2,s3\n• JSON: {\"s1\":52,\"s2\":61,\"s3\":88}\n",
        "\nValues should be 0..100"
      ])
    ])
  ];

  openModal("EMG Tuner", left, right, async ()=>{
    await controlManager.activateAsCursor("EMG");
    controlManager.enable("EMG", true);
    state.settings.emg.enabled = true;
    saveSettings();
  });

  $("#emgStart").onclick = ()=>{
    s.simMode = true;
    state.settings.emg.enabled = true;
    controlManager.enable("EMG", true);
    saveSettings();
    $("#emgToggleSim").textContent = "SIM: ON";
  };
  $("#emgToggleSim").onclick = ()=>{
    s.simMode = !s.simMode; saveSettings();
    $("#emgToggleSim").textContent = s.simMode ? "SIM: ON":"SIM: OFF";
  };
  $("#emgConnect").onclick = async ()=>{
    await controllers.EMG.connectSerial();
    renderPanelTelemetry();
  };
  $("#emgDisconnect").onclick = async ()=>{
    await controllers.EMG.disconnectSerial();
    renderPanelTelemetry();
  };
}

function tuner_EEG(){
  const s = state.settings.eeg;
  const thr = s.thr;
  const left = [
    makeCard("EEG Input", [
      el("div",{class:"hint"},[
        "EEG uses 3 signals in [-1,1]: left (horizontal), right (vertical), center (click). ",
        "SIM mode generates signals if no hardware connected."
      ]),
      el("div",{class:"row"},[
        el("button",{class:"smallbtn", id:"eegStart"},["Start (SIM)"]),
        el("button",{class:"smallbtn ghost", id:"eegToggleSim"},[s.simMode ? "SIM: ON":"SIM: OFF"]),
        el("button",{class:"smallbtn ghost", id:"eegConnect"},["Connect WebSerial"]),
        el("button",{class:"smallbtn danger", id:"eegDisconnect"},["Disconnect"])
      ]),
    ]),
    makeCard("Thresholds", [
      slider("Left Upper", -1, 1, 0.01, thr.leftUpper, (v)=>{ thr.leftUpper=v; saveSettings(); }),
      slider("Left Lower", -1, 1, 0.01, thr.leftLower, (v)=>{ thr.leftLower=v; saveSettings(); }),
      slider("Right Upper", -1, 1, 0.01, thr.rightUpper, (v)=>{ thr.rightUpper=v; saveSettings(); }),
      slider("Right Lower", -1, 1, 0.01, thr.rightLower, (v)=>{ thr.rightLower=v; saveSettings(); }),
      slider("Center Upper", -1, 1, 0.01, thr.centerUpper, (v)=>{ thr.centerUpper=v; saveSettings(); }),
      slider("Center Lower", -1, 1, 0.01, thr.centerLower, (v)=>{ thr.centerLower=v; saveSettings(); }),
    ]),
  ];

  const right = [
    makeCard("Action", [
      slider("Move Distance (px)", 2, 60, 1, s.moveDistance, (v)=>{ s.moveDistance=v|0; saveSettings(); }),
      slider("Cooldown (ms)", 0, 2000, 10, s.cooldownMs, (v)=>{ s.cooldownMs=v|0; saveSettings(); }),
      slider("WebSerial Baud", 9600, 230400, 1, s.serial.baudRate, (v)=>{ s.serial.baudRate=v|0; saveSettings(); })
    ]),
    makeCard("Live", [
      sparkline("Left", "eegSparkL", -1, 1),
      sparkline("Right", "eegSparkR", -1, 1),
      sparkline("Center", "eegSparkC", -1, 1),
      el("div",{class:"kv2"},[el("span",{},["Connected"]), el("b",{id:"eegConn"},["--"])]),
      el("div",{class:"hint"},[
        "WebSerial accepts:\n",
        "\n• CSV: l,r,c\n• JSON: {\"l\":0.22,\"r\":-0.10,\"c\":0.35}\n",
        "\nValues should be in [-1,1]"
      ])
    ]),
  ];

  openModal("EEG Tuner", left, right, async ()=>{
    await controlManager.activateAsCursor("EEG");
    controlManager.enable("EEG", true);
    state.settings.eeg.enabled = true;
    saveSettings();
  });

  $("#eegStart").onclick = ()=>{
    s.simMode = true;
    state.settings.eeg.enabled = true;
    controlManager.enable("EEG", true);
    saveSettings();
    $("#eegToggleSim").textContent = "SIM: ON";
  };
  $("#eegToggleSim").onclick = ()=>{
    s.simMode = !s.simMode; saveSettings();
    $("#eegToggleSim").textContent = s.simMode ? "SIM: ON":"SIM: OFF";
  };
  $("#eegConnect").onclick = async ()=>{
    await controllers.EEG.connectSerial();
    renderPanelTelemetry();
  };
  $("#eegDisconnect").onclick = async ()=>{
    await controllers.EEG.disconnectSerial();
    renderPanelTelemetry();
  };
}

function tuner_Tone(){
  const s = state.settings.tone;
  const tuned = s.tuned;
  const left = [
    makeCard("Tone Control", [
      el("div",{class:"hint"},[
        "Tone control maps pitch to movement using 4 tuned tones (Up/Down/Left/Right). ",
        "Use mic, or enable SIM mode for demonstration."
      ]),
      el("div",{class:"row"},[
        el("button",{class:"smallbtn", id:"toneStart"},["Start Mic"]),
        el("button",{class:"smallbtn ghost", id:"toneToggleSim"},[s.simMode ? "SIM: ON":"SIM: OFF"]),
        el("button",{class:"smallbtn gold", id:"toneStartTune"},["Start Tuning"]),
        el("button",{class:"smallbtn", id:"toneAccept"},["Accept Tone"]),
      ]),
    ]),
    makeCard("Settings", [
      slider("Tolerance (Hz)", 5, 180, 1, s.toleranceHz, (v)=>{ s.toleranceHz=v|0; saveSettings(); }),
      slider("Speed (px/s)", 100, 2200, 10, s.speed, (v)=>{ s.speed=v|0; saveSettings(); }),
      kvPair("Up Tone", "toneUp", tuned.up),
      kvPair("Down Tone", "toneDown", tuned.down),
      kvPair("Left Tone", "toneLeft", tuned.left),
      kvPair("Right Tone", "toneRight", tuned.right),
    ]),
  ];
  const right = [
    makeCard("Live Pitch", [
      el("div",{class:"hint", id:"toneLive"},["Idle"]),
      el("div",{class:"kv2"},[el("span",{},["Pitch"]), el("b",{id:"toneHz"},["--"]) ]),
      el("div",{class:"kv2"},[el("span",{},["Tuning"]), el("b",{id:"toneTuneState"},["--"]) ]),
      el("div",{style:"height:160px; border-radius:16px; border:1px solid rgba(140,180,255,.14); background:rgba(7,20,40,.35); overflow:hidden"},[
        el("canvas",{id:"toneBar", width:"320", height:"160", style:"width:100%;height:160px;display:block"})
      ])
    ]),
    makeCard("Tips", [
      el("div",{class:"hint"},[
        "For best results:\n",
        "• Use sustained vowels (\"ooo\", \"eee\")\n",
        "• Tune in a quiet room\n",
        "• Keep tones separated by 100Hz+\n"
      ])
    ])
  ];

  openModal("Tone Tuner", left, right, async ()=>{
    await controlManager.activateAsCursor("Tone");
    controlManager.enable("Tone", true);
    state.settings.tone.enabled = true;
    saveSettings();
  });

  $("#toneStart").onclick = async ()=>{
    await controlManager.ensure("Tone");
    // try resume audio context if suspended
    if(controllers.Tone.audioCtx && controllers.Tone.audioCtx.state === "suspended"){
      await controllers.Tone.audioCtx.resume();
    }
    state.settings.tone.simMode = false;
    saveSettings();
    $("#toneToggleSim").textContent = "SIM: OFF";
  };
  $("#toneToggleSim").onclick = ()=>{
    s.simMode = !s.simMode; saveSettings();
    $("#toneToggleSim").textContent = s.simMode ? "SIM: ON":"SIM: OFF";
  };
  $("#toneStartTune").onclick = async ()=>{
    await controlManager.ensure("Tone");
    controllers.Tone.startTuning();
  };
  $("#toneAccept").onclick = ()=>{
    controllers.Tone.acceptTone();
    // refresh displayed tuned values
    $("#toneUp").textContent = `${state.settings.tone.tuned.up} Hz`;
    $("#toneDown").textContent = `${state.settings.tone.tuned.down} Hz`;
    $("#toneLeft").textContent = `${state.settings.tone.tuned.left} Hz`;
    $("#toneRight").textContent = `${state.settings.tone.tuned.right} Hz`;
  };
}

// Control Selector: assigns which controller drives cursor
function controlSelector(){
  const left = [
    makeCard("Cursor Controller", [
      el("div",{class:"hint"},[
        "Choose which control system drives the in-app cursor. ",
        "Tuners refine parameters; Save in tuner activates and persists."
      ]),
      el("div",{class:"grid2"},[
        el("button",{class:"smallbtn gold", id:"selGesture"},["Gesture"]),
        el("button",{class:"smallbtn gold", id:"selRetina"},["Retina"]),
        el("button",{class:"smallbtn gold", id:"selTone"},["Tone"]),
        el("button",{class:"smallbtn gold", id:"selEMG"},["EMG"]),
        el("button",{class:"smallbtn gold", id:"selEEG"},["EEG"]),
      ]),
      el("div",{class:"hint", style:"margin-top:10px"},[
        "Tip: You can keep others enabled for telemetry, but only one drives cursor movement at a time."
      ])
    ]),
    makeCard("System Toggles", [
      el("div",{class:"row"},[
        el("button",{class:"smallbtn ghost", id:"togGesture"},[state.settings.gesture.enabled ? "Gesture: ON":"Gesture: OFF"]),
        el("button",{class:"smallbtn ghost", id:"togRetina"},[state.settings.retina.enabled ? "Retina: ON":"Retina: OFF"]),
        el("button",{class:"smallbtn ghost", id:"togTone"},[state.settings.tone.enabled ? "Tone: ON":"Tone: OFF"]),
        el("button",{class:"smallbtn ghost", id:"togEMG"},[state.settings.emg.enabled ? "EMG: ON":"EMG: OFF"]),
        el("button",{class:"smallbtn ghost", id:"togEEG"},[state.settings.eeg.enabled ? "EEG: ON":"EEG: OFF"]),
      ])
    ])
  ];
  const right = [
    makeCard("Status", [
      el("div",{class:"kv2"},[el("span",{},["Active Cursor"]), el("b",{id:"csActive"},[state.settings.active.cursorControl])]),
      el("div",{class:"kv2"},[el("span",{},["Camera"]), el("b",{id:"csCam"},[state.runtime.camReady?"READY":"OFF"])]),
      el("div",{class:"kv2"},[el("span",{},["Mic"]), el("b",{id:"csMic"},[state.runtime.micReady?"READY":"OFF"])]),
      el("div",{class:"hint"},[
        "For camera-based controls (Gesture/Retina), grant camera permission when prompted. ",
        "For Tone, mic permission is required."
      ])
    ]),
    makeCard("Security Note", [
      el("div",{class:"hint"},[
        "Browsers cannot move the OS cursor. ",
        "This console uses an internal cursor and can trigger clicks on UI elements via hover/pinch.\n\n",
        "For true OS-level control, build a native client (e.g., Electron + OS APIs)."
      ])
    ])
  ];

  openModal("Control Selector", left, right, async ()=>{ /* Save noop */ });

  const bindToggle = (key, label) => {
    const btn = $("#tog"+label);
    btn.onclick = ()=>{
      state.settings[key].enabled = !state.settings[key].enabled;
      saveSettings();
      btn.textContent = `${label}: ${state.settings[key].enabled ? "ON":"OFF"}`;
      controlManager.enable(label, state.settings[key].enabled);
    };
  };

  $("#selGesture").onclick = async ()=>{ await controlManager.activateAsCursor("Gesture"); $("#csActive").textContent="Gesture"; };
  $("#selRetina").onclick = async ()=>{ await controlManager.activateAsCursor("Retina"); $("#csActive").textContent="Retina"; };
  $("#selTone").onclick = async ()=>{ await controlManager.activateAsCursor("Tone"); $("#csActive").textContent="Tone"; };
  $("#selEMG").onclick = async ()=>{ await controlManager.activateAsCursor("EMG"); $("#csActive").textContent="EMG"; };
  $("#selEEG").onclick = async ()=>{ await controlManager.activateAsCursor("EEG"); $("#csActive").textContent="EEG"; };

  bindToggle("gesture","Gesture");
  bindToggle("retina","Retina");
  bindToggle("tone","Tone");
  bindToggle("emg","EMG");
  bindToggle("eeg","EEG");
}

// -----------------------------
// UI Builders (cards, sliders, etc.)
// -----------------------------
function makeCard(title, children=[]){
  return el("div",{class:"card"},[
    el("div",{class:"ct"},[el("span",{},[title]), el("span",{class:"badge"},["LIVE"])]),
    ...children
  ]);
}
function kvPair(label, id, valueText){
  return el("div",{class:"kv2"},[
    el("span",{},[label]),
    el("b",{id},[`${valueText} Hz`])
  ]);
}
function slider(labelText, min, max, step, value, onInput){
  const id = "sl_"+Math.random().toString(16).slice(2);
  const out = el("b",{id: id+"_v"},[String(value)]);
  const r = el("input",{type:"range", min:String(min), max:String(max), step:String(step), value:String(value)});
  r.addEventListener("input", ()=>{
    const v = Number(r.value);
    out.textContent = (step < 1 ? v.toFixed(2) : String(v));
    onInput?.(v);
  });
  return el("div",{},[
    el("label",{},[labelText]),
    r,
    el("div",{class:"kv2"},[el("span",{},[`${min}`]), out])
  ]);
}
function sparkline(title, id, minV=0, maxV=100){
  return el("div",{},[
    el("div",{class:"kv2"},[el("span",{},[title]), el("b",{id:id+"_val"},["--"])]),
    el("canvas",{id, width:"320", height:"70", style:"width:100%;height:70px;border-radius:14px;border:1px solid rgba(140,180,255,.12);background:rgba(7,20,40,.25)"})
  ]);
}

// -----------------------------
// Panel Rendering (right side telemetry + apps)
// -----------------------------
function setMode(mode){
  state.ui.mode = mode;
  badgeMode.textContent = mode.toUpperCase();
  // update active nav button styling
  document.querySelectorAll(".navbtn").forEach(b=>b.classList.remove("active"));
  const map = {
    "app:notepad":"btnNotepad",
    "app:audio":"btnAudio",
    "app:video":"btnVideo",
    "app:calendar":"btnCalendar",
    "app:games":"btnGames",
    "dashboard": null
  };
  const id = map[mode];
  if(id) $("#"+id).classList.add("active");
}

function renderPanelTelemetry(){
  panelContent.innerHTML = "";
  const c = state.cursor;
  panelContent.append(
    makeCard("Cursor", [
      el("div",{class:"kv2"},[el("span",{},["X / Y"]), el("b",{id:"tCur"},[`${Math.round(c.x)} , ${Math.round(c.y)}`])]),
      el("div",{class:"kv2"},[el("span",{},["Click"]), el("b",{id:"tClk"},[c.click ? "YES":"NO"])]),
      el("div",{class:"kv2"},[el("span",{},["Hover Target"]), el("b",{id:"tHov"},[(c.hoverTarget?.id || c.hoverTarget?.dataset?.open || c.hoverTarget?.textContent?.slice(0,18) || "--").toString()])]),
    ]),
    makeCard("Active Control", [
      el("div",{class:"kv2"},[el("span",{},["Cursor Source"]), el("b",{id:"tCtl"},[state.settings.active.cursorControl])]),
      el("div",{class:"kv2"},[el("span",{},["Hover Click"]), el("b",{id:"tHover"},[state.runtime.hoverEnabled ? "ON":"OFF"])]),
      el("div",{class:"kv2"},[el("span",{},["OS*"]), el("b",{id:"tOS"},[state.runtime.osEnabled ? "ON":"OFF"])]),
      el("div",{class:"hint"},["OS* means 'in-app automation' only."]),
    ]),
    makeCard("Gesture", [
      el("div",{class:"kv2"},[el("span",{},["Pinch"]), el("b",{id:"tPinch"},[state.telemetry.gesture.pinch ? "YES":"NO"])]),
      el("div",{class:"kv2"},[el("span",{},["Camera"]), el("b",{},[state.runtime.camReady ? "READY":"OFF"])]),
    ]),
    makeCard("Retina", [
      el("div",{class:"kv2"},[el("span",{},["Has"]), el("b",{id:"tRetHas"},[state.telemetry.retina.has ? "YES":"NO"])]),
      el("div",{class:"kv2"},[el("span",{},["X / Y"]), el("b",{id:"tRet"},[state.telemetry.retina.has ? `${Math.round(state.telemetry.retina.x)} , ${Math.round(state.telemetry.retina.y)}` : "--"])]),
    ]),
    makeCard("Tone", [
      el("div",{class:"kv2"},[el("span",{},["Pitch"]), el("b",{id:"tTone"},[state.telemetry.tone.hz ? `${Math.round(state.telemetry.tone.hz)} Hz` : "--"])]),
      el("div",{class:"kv2"},[el("span",{},["Mic"]), el("b",{},[state.runtime.micReady ? "READY":"OFF"])]),
      el("div",{class:"kv2"},[el("span",{},["SIM"]), el("b",{},[state.settings.tone.simMode ? "ON":"OFF"])]),
    ]),
    makeCard("EMG", [
      el("div",{class:"kv2"},[el("span",{},["S1/S2/S3"]), el("b",{id:"tEmg"},[`${Math.round(state.telemetry.emg.s1)} / ${Math.round(state.telemetry.emg.s2)} / ${Math.round(state.telemetry.emg.s3)}`])]),
      el("div",{class:"kv2"},[el("span",{},["Connected"]), el("b",{id:"tEmgConn"},[state.telemetry.emg.connected ? "YES":"NO"])]),
    ]),
    makeCard("EEG", [
      el("div",{class:"kv2"},[el("span",{},["L/R/C"]), el("b",{id:"tEeg"},[`${fmt(state.telemetry.eeg.l,2)} / ${fmt(state.telemetry.eeg.r,2)} / ${fmt(state.telemetry.eeg.c,2)}`])]),
      el("div",{class:"kv2"},[el("span",{},["Connected"]), el("b",{id:"tEegConn"},[state.telemetry.eeg.connected ? "YES":"NO"])]),
    ])
  );
}

function renderPanel_Notepad(){
  panelContent.innerHTML = "";
  const np = apps.notepad;
  panelContent.append(
    makeCard("Editor", [
      el("div",{class:"hint"},["Type with physical keyboard or the on-screen keyboard. Saved in localStorage."]),
      el("textarea",{
        id:"npText",
        style:"width:100%;height:240px;border-radius:16px;border:1px solid rgba(140,180,255,.14);background:rgba(7,20,40,.32);color:var(--text);padding:12px;resize:vertical;outline:none;font-family:var(--mono);font-size:12px;line-height:1.35;",
      },[np.text]),
      el("div",{class:"row"},[
        el("input",{id:"npDocName", placeholder:"Doc name", value: np.docName, style:"flex:1;padding:10px 12px;border-radius:14px;border:1px solid rgba(140,180,255,.14);background:rgba(7,20,40,.30);color:var(--text);outline:none;font-weight:800;"}),
        el("button",{class:"smallbtn gold", id:"npSave"},["Save"]),
        el("button",{class:"smallbtn", id:"npLoad"},["Load"]),
        el("button",{class:"smallbtn danger", id:"npClear"},["Clear"]),
        el("button",{class:"smallbtn ghost", id:"npBack"},["Back"]),
      ]),
    ]),
    makeCard("On-Screen Keyboard", [
      buildKeyboard((k)=>handleNotepadKey(k))
    ])
  );

  $("#npSave").onclick = ()=>{
    const name = ($("#npDocName").value || "default").trim();
    const text = $("#npText").value;
    state.settings.notepad.docs[name] = text;
    state.settings.notepad.lastDoc = name;
    saveSettings();
    np.docName = name; np.text = text;
    toast(`Saved "${name}"`);
  };
  $("#npLoad").onclick = ()=>{
    const name = ($("#npDocName").value || "default").trim();
    const text = state.settings.notepad.docs[name] ?? "";
    $("#npText").value = text;
    np.docName = name; np.text = text;
    toast(`Loaded "${name}"`);
  };
  $("#npClear").onclick = ()=>{
    $("#npText").value = "";
    np.text = "";
  };
  $("#npBack").onclick = ()=>{
    setMode("dashboard");
    panelTitle.textContent = "LIVE TELEMETRY";
    panelSub.textContent = "Cursor • Click • Signals";
    renderPanelTelemetry();
  };
  $("#npText").addEventListener("input", ()=>{
    np.text = $("#npText").value;
  });
}

function handleNotepadKey(key){
  const ta = $("#npText");
  if(!ta) return;
  if(key === "Backspace"){
    ta.value = ta.value.slice(0, -1);
  }else if(key === "Enter"){
    ta.value += "\n";
  }else if(key === "Space"){
    ta.value += " ";
  }else{
    ta.value += key;
  }
  ta.dispatchEvent(new Event("input"));
}

function buildKeyboard(onKey){
  const rows = [
    ["1","2","3","4","5","6","7","8","9","0"],
    ["Q","W","E","R","T","Y","U","I","O","P"],
    ["A","S","D","F","G","H","J","K","L","Enter"],
    ["Z","X","C","V","B","N","M",",",".","/"],
    ["Space","Backspace"]
  ];
  const k = el("div",{class:"kbd"});
  for(const row of rows){
    for(const key of row){
      let cls = "key";
      if(key === "Space") cls += " wider";
      if(key === "Backspace") cls += " wide danger";
      if(key === "Enter") cls += " wide gold";
      k.append(el("div",{class:cls, onclick:()=>onKey(key)},[key]));
    }
  }
  return k;
}

function renderPanel_Audio(){
  panelContent.innerHTML = "";
  const a = apps.audio;
  panelContent.append(
    makeCard("Recorder", [
      el("div",{class:"hint"},["Use Record/Stop. Playback will appear below."]),
      el("div",{class:"row"},[
        el("button",{class:"smallbtn gold", id:"auRec"},[a.recording ? "Recording…" : "Record"]),
        el("button",{class:"smallbtn danger", id:"auStop"},["Stop"]),
        el("button",{class:"smallbtn", id:"auDl"},["Download"]),
        el("button",{class:"smallbtn ghost", id:"auBack"},["Back"]),
      ]),
      el("audio",{id:"audioPlayback", controls:"", style:"width:100%;margin-top:10px;"})
    ]),
    makeCard("Notes", [
      el("div",{class:"hint"},[
        "Audio is recorded as WebM/Opus in most browsers.\n",
        "For WAV export, add a server-side transcoder."
      ])
    ])
  );

  $("#auRec").onclick = ()=>a.start();
  $("#auStop").onclick = ()=>a.stop();
  $("#auDl").onclick = ()=>a.download();
  $("#auBack").onclick = ()=>{
    setMode("dashboard");
    panelTitle.textContent = "LIVE TELEMETRY";
    panelSub.textContent = "Cursor • Click • Signals";
    renderPanelTelemetry();
  };
}

function renderPanel_Video(){
  panelContent.innerHTML = "";
  const v = apps.video;
  panelContent.append(
    makeCard("Recorder", [
      el("div",{class:"hint"},["Record is capped at 10 seconds (like desktop). You can preview camera feed."]),
      el("div",{class:"row"},[
        el("button",{class:"smallbtn gold", id:"viRec"},[v.recording ? "Recording…" : "Record 10s"]),
        el("button",{class:"smallbtn danger", id:"viStop"},["Stop"]),
        el("button",{class:"smallbtn", id:"viPrev"},[v.previewOn ? "Preview: ON" : "Preview: OFF"]),
        el("button",{class:"smallbtn", id:"viDl"},["Download"]),
        el("button",{class:"smallbtn ghost", id:"viBack"},["Back"]),
      ]),
      el("video",{id:"videoPreview", controls:"", muted:"", playsinline:"", class: v.previewOn ? "" : "hidden", style:"width:100%;margin-top:10px;border-radius:16px;border:1px solid rgba(140,180,255,.12);background:rgba(0,0,0,.2)"}),
      el("video",{id:"videoPlayback", controls:"", playsinline:"", style:"width:100%;margin-top:10px;border-radius:16px;border:1px solid rgba(140,180,255,.12);background:rgba(0,0,0,.2)"})
    ]),
    makeCard("Tips", [
      el("div",{class:"hint"},[
        "Video is recorded as WebM in most browsers.\n",
        "On iOS Safari, MediaRecorder may be limited."
      ])
    ])
  );

  $("#viRec").onclick = ()=>v.start();
  $("#viStop").onclick = ()=>v.stop();
  $("#viPrev").onclick = ()=>v.togglePreview();
  $("#viDl").onclick = ()=>v.download();
  $("#viBack").onclick = ()=>{
    setMode("dashboard");
    panelTitle.textContent = "LIVE TELEMETRY";
    panelSub.textContent = "Cursor • Click • Signals";
    renderPanelTelemetry();
  };
}

function renderPanel_Calendar(){
  panelContent.innerHTML = "";
  const cal = new CalendarUI();
  panelContent.append(cal.render());
}
class CalendarUI{
  constructor(){
    const d = new Date();
    this.year = d.getFullYear();
    this.month = d.getMonth(); // 0-based
    this.selected = null; // yyyy-mm-dd
  }
  key(y,m,day){
    const mm = String(m+1).padStart(2,"0");
    const dd = String(day).padStart(2,"0");
    return `${y}-${mm}-${dd}`;
  }
  render(){
    const wrap = el("div",{});
    const header = el("div",{class:"row"},[
      el("button",{class:"smallbtn", onclick:()=>{this.prev();}},["◀"]),
      el("div",{class:"card", style:"flex:1;padding:10px 12px;text-align:center"},[
        el("div",{style:"font-weight:950;letter-spacing:.3px;color:rgba(242,213,122,.92)"},[
          new Date(this.year, this.month, 1).toLocaleString(undefined, {month:"long", year:"numeric"})
        ])
      ]),
      el("button",{class:"smallbtn", onclick:()=>{this.next();}},["▶"]),
      el("button",{class:"smallbtn ghost", onclick:()=>{ setMode("dashboard"); panelTitle.textContent="LIVE TELEMETRY"; panelSub.textContent="Cursor • Click • Signals"; renderPanelTelemetry(); }},["Back"]),
    ]);
    wrap.append(header);

    const grid = el("div",{class:"card", style:"padding:12px"});
    const days = ["Mon","Tue","Wed","Thu","Fri","Sat","Sun"];
    const top = el("div",{class:"grid7", style:"display:grid;grid-template-columns:repeat(7,1fr);gap:8px;margin-bottom:10px"});
    for(const d of days){
      top.append(el("div",{style:"text-align:center;font-weight:900;color:rgba(234,242,255,.85);font-size:12px"},[d]));
    }
    grid.append(top);

    const body = el("div",{style:"display:grid;grid-template-columns:repeat(7,1fr);gap:8px"});
    const first = new Date(this.year, this.month, 1);
    // compute Monday-based offset
    let start = (first.getDay()+6)%7; // 0=Mon
    const daysInMonth = new Date(this.year, this.month+1, 0).getDate();
    for(let i=0;i<start;i++){
      body.append(el("div",{style:"height:44px;opacity:.2"}));
    }
    for(let day=1; day<=daysInMonth; day++){
      const key = this.key(this.year,this.month,day);
      const booking = state.settings.calendar.bookings[key];
      const cell = el("button",{
        class:"navbtn",
        style:"height:44px; padding:8px 10px; border-radius:14px; justify-content:center; text-align:center; font-weight:950; position:relative;",
        onclick:()=>this.openBooking(key)
      },[String(day)]);
      if(booking){
        cell.style.borderColor = "rgba(212,175,55,.45)";
        cell.style.background = "linear-gradient(180deg, rgba(212,175,55,.18), rgba(7,20,40,.55))";
        const dot = el("div",{style:"position:absolute;right:10px;top:10px;width:10px;height:10px;border-radius:999px;background:rgba(50,213,131,.95);box-shadow:0 0 18px rgba(50,213,131,.35)"});
        cell.append(dot);
      }
      body.append(cell);
    }
    grid.append(body);
    wrap.append(grid);

    // booking details panel
    const detail = el("div",{class:"card", style:"padding:12px"},[
      el("div",{class:"ct"},[el("span",{},["Booking"]), el("span",{class:"badge"},["LOCAL"])]),
      el("div",{class:"hint"},["Select a day to add or edit a booking. Stored locally."]),
      el("div",{id:"calDetail"})
    ]);
    wrap.append(detail);

    // If selection exists show it
    if(this.selected) this.renderDetail(this.selected);

    return wrap;
  }
  prev(){
    this.month--;
    if(this.month<0){ this.month=11; this.year--; }
    renderPanel_Calendar();
  }
  next(){
    this.month++;
    if(this.month>11){ this.month=0; this.year++; }
    renderPanel_Calendar();
  }
  openBooking(key){
    this.selected = key;
    this.renderDetail(key);
  }
  renderDetail(key){
    const target = $("#calDetail");
    if(!target) return;
    target.innerHTML = "";
    const booking = state.settings.calendar.bookings[key] || {time:"", text:""};

    const times = Array.from({length:24}).map((_,h)=>String(h).padStart(2,"0")+":00");
    const timeSel = el("select",{id:"calTime", style:"width:100%;padding:10px 12px;border-radius:14px;border:1px solid rgba(140,180,255,.14);background:rgba(7,20,40,.30);color:var(--text);outline:none;font-weight:800;"});
    timeSel.append(el("option",{value:""},["Select time…"]));
    for(const t of times){
      timeSel.append(el("option",{value:t, selected: booking.time===t ? "selected":null},[t]));
    }
    const text = el("textarea",{id:"calText", style:"width:100%;height:110px;border-radius:16px;border:1px solid rgba(140,180,255,.14);background:rgba(7,20,40,.32);color:var(--text);padding:12px;resize:vertical;outline:none;font-family:var(--mono);font-size:12px;line-height:1.35;"},[booking.text||""]);
    const row = el("div",{class:"row"},[
      el("button",{class:"smallbtn gold", onclick:()=>this.saveBooking(key)},["Save"]),
      el("button",{class:"smallbtn danger", onclick:()=>this.deleteBooking(key)},["Delete"]),
    ]);

    target.append(
      el("div",{class:"kv2"},[el("span",{},["Date"]), el("b",{},[key])]),
      el("div",{style:"height:8px"}),
      el("label",{},["Time"]),
      timeSel,
      el("div",{style:"height:8px"}),
      el("label",{},["Details"]),
      text,
      el("div",{style:"height:10px"}),
      row
    );
  }
  saveBooking(key){
    const time = $("#calTime").value;
    const text = $("#calText").value;
    state.settings.calendar.bookings[key] = {time, text};
    saveSettings();
    toast("Booking saved");
    renderPanel_Calendar();
  }
  deleteBooking(key){
    delete state.settings.calendar.bookings[key];
    saveSettings();
    toast("Booking deleted");
    renderPanel_Calendar();
  }
}

function renderPanel_Games(){
  panelContent.innerHTML = "";
  const g = apps.games;
  g.pong.active = true;
  panelContent.append(
    makeCard("Pong", [
      el("div",{class:"hint"},[
        "Move the cursor vertically to control the left paddle.\n",
        "Switch to Retina/Tone/EMG/EEG and play hands-free."
      ]),
      el("div",{class:"row"},[
        el("button",{class:"smallbtn gold", onclick:()=>{ g.pong.reset(); g.pong.active=true; }},["Restart"]),
        el("button",{class:"smallbtn ghost", onclick:()=>{ g.pong.active=false; setMode('dashboard'); panelTitle.textContent='LIVE TELEMETRY'; panelSub.textContent='Cursor • Click • Signals'; renderPanelTelemetry(); }},["Back"]),
      ])
    ])
  );
}

function toast(msg){
  // lightweight toast using panelSub
  panelSub.textContent = msg;
  setTimeout(()=>{
    if(state.ui.mode === "dashboard"){
      panelSub.textContent = "Cursor • Click • Signals";
    }
  }, 1800);
}

// -----------------------------
// Controllers registry
// -----------------------------
const controllers = {
  Gesture: new GestureController(),
  Retina: new RetinaController(),
  Tone: new ToneController(),
  EMG: new EMGController(),
  EEG: new EEGController()
};
const apps = {
  notepad: new NotepadApp(),
  audio: new AudioApp(),
  video: new VideoApp(),
  calendar: new CalendarApp(),
  games: new GamesApp()
};

// -----------------------------
// Wait for global constructor (MediaPipe load)
// -----------------------------
function waitForGlobal(name, timeoutMs=12000){
  return new Promise((resolve, reject)=>{
    const start = nowMs();
    const tick = ()=>{
      if(window[name]) return resolve(window[name]);
      if(nowMs() - start > timeoutMs) return reject(new Error(`Timeout waiting for ${name}`));
      requestAnimationFrame(tick);
    };
    tick();
  });
}

// -----------------------------
// Input Routing + Hover Click
// -----------------------------
function updateCursorUI(){
  cursorEl.style.transform = `translate(${state.cursor.x - 12}px, ${state.cursor.y - 12}px)`;
  cursorEl.classList.toggle("click", state.cursor.click);
}

function performClickAtCursor(){
  if(!state.runtime.osEnabled) return;
  const elAt = document.elementFromPoint(state.cursor.x, state.cursor.y);
  if(!elAt) return;

  // avoid clicking the cursor itself
  if(elAt.id === "cursor") return;

  // attempt click
  try{
    elAt.click();
  }catch(e){}
}

function updateHoverClick(){
  if(!state.runtime.hoverEnabled || !state.runtime.osEnabled) {
    state.cursor.hoverTarget = null;
    state.cursor.hoverStartMs = 0;
    return;
  }
  const t = nowMs();
  const elAt = document.elementFromPoint(state.cursor.x, state.cursor.y);
  if(!elAt || elAt.id === "cursor"){
    state.cursor.hoverTarget = null;
    state.cursor.hoverStartMs = 0;
    return;
  }

  // Determine if element is "clickable"
  const clickable = elAt.closest("button, a, [role='button'], .key, .navbtn, .btn, .smallbtn") || elAt;
  const target = clickable;

  if(state.cursor.hoverTarget !== target){
    state.cursor.hoverTarget = target;
    state.cursor.hoverStartMs = t;
  }else{
    const dwell = t - state.cursor.hoverStartMs;
    if(dwell >= state.settings.ui.hoverTime){
      // Trigger click and reset
      performClickAtCursor();
      state.cursor.hoverStartMs = t + 999999; // block until cursor moves
    }
  }
}

// -----------------------------
// Dashboard / Nav actions
// -----------------------------
function wireNav(){
  const openMap = {
    internet: ()=>window.open("https://www.google.com", "_blank", "noopener"),
    games: ()=>apps.games.open(),
    notepad: ()=>apps.notepad.open(),
    audio: ()=>apps.audio.open(),
    video: ()=>apps.video.open(),
    calendar: ()=>apps.calendar.open(),
    controlSelector: ()=>controlSelector(),
    retinaTuner: ()=>tuner_Retina(),
    emgTuner: ()=>tuner_EMG(),
    eegTuner: ()=>tuner_EEG(),
    toneTuner: ()=>tuner_Tone(),
    gestureTuner: ()=>tuner_Gesture()
  };

  document.querySelectorAll("[data-open]").forEach(btn=>{
    btn.addEventListener("click", async ()=>{
      const key = btn.dataset.open;
      openMap[key]?.();
    });
  });

  $("#btnToggleHover").onclick = ()=>{
    state.runtime.hoverEnabled = !state.runtime.hoverEnabled;
    state.settings.ui.hoverClick = state.runtime.hoverEnabled;
    saveSettings();
    $("#btnToggleHover").textContent = state.runtime.hoverEnabled ? "Hover Click" : "Hover OFF";
    kvHover.textContent = state.runtime.hoverEnabled ? "ON" : "OFF";
  };
  $("#btnToggleOS").onclick = ()=>{
    // cannot do OS-level. toggles in-app automation
    state.runtime.osEnabled = !state.runtime.osEnabled;
    kvOS.textContent = state.runtime.osEnabled ? "IN-APP" : "OFF";
    dotCtl.classList.toggle("ok", state.runtime.osEnabled);
    dotCtl.classList.toggle("bad", !state.runtime.osEnabled);
  };

  // hotkeys
  window.addEventListener("keydown", (e)=>{
    if(e.key === "F11"){
      e.preventDefault();
      $("#btnToggleHover").click();
    }
    if(e.key === "F12"){
      e.preventDefault();
      $("#btnToggleOS").click();
    }
    if(e.altKey){
      const k = e.key.toLowerCase();
      if(k === "i") $("#btnInternet").click();
      if(k === "g") $("#btnGames").click();
      if(k === "n") $("#btnNotepad").click();
      if(k === "a") $("#btnAudio").click();
      if(k === "v") $("#btnVideo").click();
      if(k === "c") $("#btnCalendar").click();
      if(k === "s") $("#btnControlSelector").click();
      if(k === "r") $("#btnRetinaTuner").click();
      if(k === "e") $("#btnEmgTuner").click();
      if(k === "q") $("#btnEegTuner").click();
      if(k === "t") $("#btnToneTuner").click();
      if(k === "h") $("#btnGestureTuner").click();
    }
    if(e.key === "Escape"){
      if(state.ui.modalOpen) closeModal();
      else {
        // back to dashboard
        setMode("dashboard");
        panelTitle.textContent = "LIVE TELEMETRY";
        panelSub.textContent = "Cursor • Click • Signals";
        renderPanelTelemetry();
      }
    }
  });
}

// -----------------------------
// Visualization: background grid + graphs
// -----------------------------
function draw(ctx, dt){
  const rect = viz.getBoundingClientRect();
  const w = rect.width, h = rect.height;

  // Clear
  ctx.clearRect(0,0,w,h);

  // Soft grid in viewport (for visual alignment)
  ctx.save();
  ctx.globalAlpha = 0.25;
  ctx.strokeStyle = "rgba(140,180,255,.10)";
  const gs = clamp(state.settings.retina.gridSize || 48, 16, 120);
  if(state.settings.retina.showGrid){
    ctx.beginPath();
    for(let x=0; x<w; x+=gs){
      ctx.moveTo(x,0); ctx.lineTo(x,h);
    }
    for(let y=0; y<h; y+=gs){
      ctx.moveTo(0,y); ctx.lineTo(w,y);
    }
    ctx.stroke();
  }
  ctx.restore();

  // Draw mini pitch bar inside viewport corner
  drawToneBarInViewport(ctx, w, h);

  // Draw EMG/EEG sparklines inside modal if present
  if(state.ui.modalOpen){
    drawModalSparklines();
    drawToneModalBar();
    updateModalLiveLabels();
  }

  // Games overlay (pong)
  apps.games.pong.draw(ctx, w, h);

  // Draw status watermark
  ctx.save();
  ctx.globalAlpha = 0.75;
  ctx.fillStyle = "rgba(242,213,122,.55)";
  ctx.font = "800 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
  ctx.fillText(`MODE: ${state.ui.mode.toUpperCase()} • CURSOR: ${state.settings.active.cursorControl.toUpperCase()} • FPS: ${Math.round(state.runtime.fps)}`, 18, h - 18);
  ctx.restore();
}

function drawToneBarInViewport(ctx, w, h){
  const hz = state.telemetry.tone.hz || 0;
  const minHz = 50, maxHz = 2000;
  const t = clamp((hz - minHz)/(maxHz-minHz), 0, 1);

  const barW = 22;
  const barH = 210;
  const x = w - 34;
  const y = 18;

  ctx.save();
  ctx.globalAlpha = 0.85;
  ctx.fillStyle = "rgba(7,20,40,.45)";
  roundRect(ctx, x-6, y-6, barW+12, barH+12, 14);
  ctx.fill();

  // border
  ctx.strokeStyle = "rgba(212,175,55,.22)";
  ctx.lineWidth = 1;
  roundRect(ctx, x-6, y-6, barW+12, barH+12, 14);
  ctx.stroke();

  // fill
  ctx.fillStyle = "rgba(212,175,55,.85)";
  const fillH = barH * t;
  ctx.fillRect(x, y + (barH-fillH), barW, fillH);

  ctx.fillStyle = "rgba(234,242,255,.78)";
  ctx.font = "800 11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
  ctx.textAlign = "right";
  ctx.fillText(hz ? `${Math.round(hz)}Hz` : "--", x-10, y + 10);

  ctx.restore();
}

function roundRect(ctx, x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}

// -----------------------------
// Modal Live Updates
// -----------------------------
function updateModalLiveLabels(){
  // Gesture modal
  const gesPin = $("#gesPinch");
  if(gesPin){
    gesPin.textContent = state.telemetry.gesture.pinch ? "YES" : "NO";
    const p = state.cursor;
    $("#gesPos").textContent = `${Math.round(p.x)} , ${Math.round(p.y)}`;
    $("#gesCam").textContent = state.settings.gesture.simMode ? "SIM" : (state.runtime.camReady ? "READY" : "OFF");
    $("#gesLive").textContent = state.settings.gesture.simMode
      ? "SIM running."
      : (state.runtime.camReady ? "Camera ready. Show one hand." : "Waiting for camera permission…");
  }

  // Retina modal
  const rHas = $("#retinaHas");
  if(rHas){
    rHas.textContent = state.telemetry.retina.has ? "YES" : "NO";
    $("#retinaX").textContent = state.telemetry.retina.has ? String(Math.round(state.telemetry.retina.x)) : "--";
    $("#retinaY").textContent = state.telemetry.retina.has ? String(Math.round(state.telemetry.retina.y)) : "--";
    $("#retinaLive").textContent = state.settings.retina.simMode
      ? "SIM running."
      : (state.runtime.camReady ? "Camera ready. Track your face." : "Waiting for camera permission…");
  }

  // EMG
  const emgConn = $("#emgConn");
  if(emgConn){
    emgConn.textContent = controllers.EMG.connected ? "YES" : "NO";
    $("#emgLive").textContent = state.settings.emg.simMode
      ? "SIM running"
      : (controllers.EMG.connected ? "Serial streaming" : "Disconnected");
  }

  // EEG
  const eegConn = $("#eegConn");
  if(eegConn){
    eegConn.textContent = controllers.EEG.connected ? "YES" : "NO";
  }

  // Tone
  const toneHz = $("#toneHz");
  if(toneHz){
    toneHz.textContent = state.telemetry.tone.hz ? `${Math.round(state.telemetry.tone.hz)} Hz` : "--";
    const tc = controllers.Tone;
    const dir = tc.tuning.directions[tc.tuning.directionIndex] || "--";
    $("#toneTuneState").textContent = tc.tuning.active ? `TUNING: ${dir.toUpperCase()}` : "OFF";
    $("#toneLive").textContent = state.settings.tone.simMode
      ? "SIM mode"
      : (state.runtime.micReady ? "Mic active" : "Mic idle / blocked");
  }
}

function drawModalSparklines(){
  // EMG
  drawSpark("emgSpark1", controllers.EMG.hist1.toArray(), 0, 100);
  drawSpark("emgSpark2", controllers.EMG.hist2.toArray(), 0, 100);
  drawSpark("emgSpark3", controllers.EMG.hist3.toArray(), 0, 100);
  const e1 = $("#emgSpark1_val");
  if(e1){
    e1.textContent = String(Math.round(state.telemetry.emg.s1));
    $("#emgSpark2_val").textContent = String(Math.round(state.telemetry.emg.s2));
    $("#emgSpark3_val").textContent = String(Math.round(state.telemetry.emg.s3));
  }

  // EEG
  drawSpark("eegSparkL", controllers.EEG.histL.toArray(), -1, 1);
  drawSpark("eegSparkR", controllers.EEG.histR.toArray(), -1, 1);
  drawSpark("eegSparkC", controllers.EEG.histC.toArray(), -1, 1);
  const l = $("#eegSparkL_val");
  if(l){
    l.textContent = fmt(state.telemetry.eeg.l,2);
    $("#eegSparkR_val").textContent = fmt(state.telemetry.eeg.r,2);
    $("#eegSparkC_val").textContent = fmt(state.telemetry.eeg.c,2);
  }
}

function drawSpark(canvasId, data, minV, maxV){
  const c = document.getElementById(canvasId);
  if(!c) return;
  const ctx = c.getContext("2d");
  const w = c.width, h = c.height;
  ctx.clearRect(0,0,w,h);

  // background
  ctx.fillStyle = "rgba(7,20,40,.32)";
  ctx.fillRect(0,0,w,h);

  if(data.length < 2) return;

  ctx.strokeStyle = "rgba(242,213,122,.70)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  for(let i=0;i<data.length;i++){
    const x = (i/(data.length-1))*w;
    const t = (data[i]-minV)/(maxV-minV);
    const y = h - clamp(t,0,1)*h;
    if(i===0) ctx.moveTo(x,y);
    else ctx.lineTo(x,y);
  }
  ctx.stroke();

  // baseline
  ctx.strokeStyle = "rgba(140,180,255,.14)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0,h/2); ctx.lineTo(w,h/2); ctx.stroke();
}

function drawToneModalBar(){
  const c = $("#toneBar");
  if(!c) return;
  const ctx = c.getContext("2d");
  const w = c.width, h = c.height;
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = "rgba(7,20,40,.32)";
  ctx.fillRect(0,0,w,h);

  const hz = state.telemetry.tone.hz || 0;
  const minHz = 50, maxHz = 2000;
  const t = clamp((hz - minHz)/(maxHz-minHz), 0, 1);

  // bar
  const barW = 26;
  const barH = h - 24;
  const x = 18;
  const y = 12;

  ctx.fillStyle = "rgba(140,180,255,.12)";
  roundRectPx(ctx, x-6, y-6, barW+12, barH+12, 12);
  ctx.fill();

  ctx.strokeStyle = "rgba(212,175,55,.22)";
  ctx.lineWidth = 1;
  roundRectPx(ctx, x-6, y-6, barW+12, barH+12, 12);
  ctx.stroke();

  ctx.fillStyle = "rgba(212,175,55,.85)";
  const fillH = barH * t;
  ctx.fillRect(x, y + (barH - fillH), barW, fillH);

  // tuned markers
  const tuned = state.settings.tone.tuned;
  const dirs = [["UP", tuned.up],["DOWN", tuned.down],["LEFT", tuned.left],["RIGHT", tuned.right]];
  ctx.fillStyle = "rgba(234,242,255,.82)";
  ctx.font = "800 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
  ctx.textAlign = "left";
  let yy = 20;
  for(const [name,val] of dirs){
    ctx.fillText(`${name}: ${val}Hz`, 70, yy);
    yy += 22;
  }

  ctx.fillStyle = "rgba(234,242,255,.92)";
  ctx.font = "900 14px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
  ctx.fillText(hz ? `LIVE: ${Math.round(hz)}Hz` : "LIVE: --", 70, h - 14);
}

function roundRectPx(ctx, x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}

// -----------------------------
// Main Loop
// -----------------------------
function tick(){
  const t = nowMs();
  const dt = clamp(t - state.runtime.lastFrameMs, 4, 60); // clamp dt
  state.runtime.lastFrameMs = t;

  // FPS
  const fps = 1000 / dt;
  state.runtime.fps = lerp(state.runtime.fps, fps, 0.08);

  // Update controls
  const out = controlManager.update(dt);

  // Apply cursor movement
  if(out.setPos){
    state.cursor.x = out.setPos[0];
    state.cursor.y = out.setPos[1];
  }else{
    state.cursor.x += out.dx || 0;
    state.cursor.y += out.dy || 0;
  }
  state.cursor.x = clamp(state.cursor.x, 0, window.innerWidth);
  state.cursor.y = clamp(state.cursor.y, 0, window.innerHeight);

  // Click edge detection
  state.cursor.lastClick = state.cursor.click;
  state.cursor.click = !!out.click;
  state.cursor.clickEdge = state.cursor.click && !state.cursor.lastClick;
  if(state.cursor.clickEdge){
    performClickAtCursor();
  }

  // Hover click
  updateHoverClick();

  // Games update
  apps.games.pong.update(dt);

  // Update cursor overlay
  updateCursorUI();

  // Telemetry panel refresh periodically if on dashboard
  if(state.ui.mode === "dashboard"){
    // update lightweight live values in place
    const tCur = $("#tCur");
    if(tCur) tCur.textContent = `${Math.round(state.cursor.x)} , ${Math.round(state.cursor.y)}`;
    const tClk = $("#tClk");
    if(tClk) tClk.textContent = state.cursor.click ? "YES" : "NO";
    const tPinch = $("#tPinch");
    if(tPinch) tPinch.textContent = state.telemetry.gesture.pinch ? "YES":"NO";
    const tRet = $("#tRet");
    if(tRet) tRet.textContent = state.telemetry.retina.has ? `${Math.round(state.telemetry.retina.x)} , ${Math.round(state.telemetry.retina.y)}` : "--";
    const tRetHas = $("#tRetHas");
    if(tRetHas) tRetHas.textContent = state.telemetry.retina.has ? "YES":"NO";
    const tTone = $("#tTone");
    if(tTone) tTone.textContent = state.telemetry.tone.hz ? `${Math.round(state.telemetry.tone.hz)} Hz` : "--";
    const tEmg = $("#tEmg");
    if(tEmg) tEmg.textContent = `${Math.round(state.telemetry.emg.s1)} / ${Math.round(state.telemetry.emg.s2)} / ${Math.round(state.telemetry.emg.s3)}`;
    const tEeg = $("#tEeg");
    if(tEeg) tEeg.textContent = `${fmt(state.telemetry.eeg.l,2)} / ${fmt(state.telemetry.eeg.r,2)} / ${fmt(state.telemetry.eeg.c,2)}`;
    const tEmgConn = $("#tEmgConn");
    if(tEmgConn) tEmgConn.textContent = state.telemetry.emg.connected ? "YES":"NO";
    const tEegConn = $("#tEegConn");
    if(tEegConn) tEegConn.textContent = state.telemetry.eeg.connected ? "YES":"NO";
  }

  // Draw viewport
  const ctx = viz.getContext("2d");
  draw(ctx, dt);

  requestAnimationFrame(tick);
}

// -----------------------------
// Boot
// -----------------------------
function boot(){
  resizeCanvas();
  wireNav();

  // initialize top toggles from settings
  state.runtime.hoverEnabled = !!state.settings.ui.hoverClick;
  state.runtime.osEnabled = true;
  kvHover.textContent = state.runtime.hoverEnabled ? "ON":"OFF";
  kvOS.textContent = "IN-APP";
  badgeControl.textContent = state.settings.active.cursorControl.toUpperCase();
  kvCursor.textContent = state.settings.active.cursorControl.toUpperCase();

  // Enable controllers according to settings
  controlManager.enable("Gesture", state.settings.gesture.enabled);
  controlManager.enable("Retina", state.settings.retina.enabled);
  controlManager.enable("Tone", state.settings.tone.enabled);
  controlManager.enable("EMG", state.settings.emg.enabled);
  controlManager.enable("EEG", state.settings.eeg.enabled);

  // Start with dashboard telemetry
  setMode("dashboard");
  renderPanelTelemetry();

  // Clock
  setInterval(()=>{
    const d = new Date();
    clockEl.textContent = d.toLocaleTimeString(undefined, {hour12:false});
  }, 250);

  // Dots
  dotCam.classList.add("bad");
  dotMic.classList.add("bad");

  // Prime permissions on first user gesture (recommended by browsers).
  // This makes the active cursor controller start immediately after the first click/tap.
  window.addEventListener("pointerdown", async () => {
    try{
      await controlManager.ensure(state.settings.active.cursorControl);
      // For camera-based controls, set the dots if permission granted.
    }catch(e){}
  }, { once:true });

  // Run loop
  requestAnimationFrame(tick);
}

boot();

</script>
  <script src="static/omconsole-launcher.js"></script>
</body>
</html>
